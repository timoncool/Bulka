[
  {
    "id": "functions-intro",
    "title": "JavaScript API",
    "content": "# Функции Pattern\n\nДавайте изучим всё о функциях для создания и модификации patterns.\nВ основе Strudel всё состоит из функций.\n\nНапример, всё, что вы можете сделать с помощью Mini-Notation, также можно сделать с помощью функции.\nЭтот Pattern в Mini Notation:\n\nэквивалентен этому Pattern без Mini Notation:\n\nАналогично, есть эквивалентная функция для каждого аспекта mini notation.\n\nКакое представление использовать - вопрос контекста. Как правило, функции\nлучше подходят в более широком контексте, в то время как mini notation более практична для отдельных ритмов.\n\n## Ограничения Mini Notation\n\nХотя Mini Notation - это мощный способ писать ритмы лаконично, у неё также есть ограничения. Возьмём этот пример:\n\nЗдесь мы используем mini notation для отдельных ритмов, при этом используя функцию `stack` для их микширования.\nХотя stack также доступен как `,` в mini notation, мы не можем использовать его здесь, потому что у нас разные типы звуков.\n\n## Комбинирование Patterns\n\nВы можете свободно смешивать JS patterns, mini patterns и значения! Например, этот pattern:\n\n...эквивалентен:\n\n... а также:\n\nХотя mini notation почти всегда короче, у неё есть только несколько модификаторов: \\* / ! @.\nПри использовании JS patterns можно сделать гораздо больше.\n\nДалее давайте посмотрим, как вы можете [создавать patterns](/learn/factories)",
    "category": "functions",
    "keywords": [
      "javascript",
      "api",
      "pattern",
      "patterns",
      "strudel",
      "mini",
      "notation",
      "stack",
      "learn",
      "factories"
    ],
    "path": "functions/intro.mdx"
  },
  {
    "id": "functions-value-modifiers",
    "title": "Параметры управления",
    "content": "# Параметры управления\n\nПомимо функций, которые контролируют время, мы видели ранее, что функции вроде `note` и `cutoff` контролируют различные параметры (короткие params) события.\nТеперь давайте более внимательно посмотрим, как работают эти `функции param(eter)`.\n\n# Функции параметров\n\nОчень мощная особенность tidal patterns - это то, что каждый параметр может контролироваться независимо:\n\nВ этом примере параметры `note`, `cutoff`, `gain` и `s` контролируются независимо либо patterns, либо обычными значениями (числами / текстом).\nПосле нажатия play мы можем наблюдать время и значения параметров каждого события (hap) в выводе, созданном `.log()`.\n\n## Обычные vs параметризованные значения\n\nPatterns, которые не обёрнуты в функцию param, будут содержать немаркированные `обычные значения`:\n\nЭто не создаст звукового вывода, потому что Strudel мог бы только догадываться, какой param имеется в виду этими буквами.\n\nТеперь сравните это с версией, обёрнутой в `note`:\n\nТеперь ясно, что эти буквы предназначены для воспроизведения как ноты.\nПод капотом функция `note` (как и все другие функции param)\nобернёт каждое обычное значение в объект. Если бы функции note не существовало, нам пришлось бы писать:\n\nЭто будет иметь тот же вывод, хотя это довольно неудобно читать и писать.\n\n## Обёртывание функций параметров\n\nЧтобы избежать слишком большой вложенности, функции param также можно связывать в цепочку вот так:\n\nЭто эквивалентно `note(cat('c','e','g')).log()`.\n\nВы можете использовать это с любой функцией, которая объявляет тип (как `n`, `s`, `note`, `freq` и т.д.), просто убедитесь, что оставляете скобки пустыми!\n\n## Модификация обычных значений\n\nPatterns обычных значений могут быть изменены с помощью любого из следующих операторов:\n\nЗдесь функция add изменяет числа слева.\nСнова нет вывода, потому что эти числа не имеют смысла без param.\n\n## Модификация значений параметров\n\nЧтобы изменить значение параметра, вы можете либо:\n\n- Использовать оператор на pattern обычных значений внутри функции param:\n\n  \n\n- Аналогично, использовать оператор на pattern обычных значений и обернуть его позже:\n\n  \n\n- Указать, какой param должен быть изменён внутри функции оператора:\n\n  \n\nПомните, что выполнение связанных функций идёт слева направо.\n\n# Операторы\n\nЭта группа функций позволяет изменять значение событий.\n\n## add\n\n## sub\n\n## mul\n\n## div\n\n## round\n\n## floor\n\n## ceil\n\n## range\n\n## rangex\n\n## range2\n\n## ratio\n\n## as\n\n# Пользовательские параметры\n\nВы также можете создавать свои собственные параметры:\n\nНесколько params также можно создать более лаконичным способом, используя `createParams`:\n\nОбратите внимание, что эти params ничего не будут делать, пока вы не придадите им смысл в вашем пользовательском выводе!\n\nОт модификации параметров мы переходим к концепции [Signals](/learn/signals).",
    "category": "functions",
    "keywords": [
      "параметры",
      "управления",
      "param",
      "log",
      "note",
      "cat",
      "cutoff",
      "params",
      "eter",
      "tidal",
      "patterns",
      "gain",
      "play",
      "strudel",
      "freq",
      "pattern",
      "round",
      "floor",
      "ceil",
      "range"
    ],
    "path": "functions/value-modifiers.mdx"
  },
  {
    "id": "hydra-audio",
    "title": "Аудио-реактивность",
    "content": "# Аудио-реактивность\n\nHydra может создавать визуализации, реагирующие на звук в реальном времени через FFT анализ.\n\n## Объект `a` — аудио анализ\n\n| Свойство/Метод | Описание |\n|----------------|----------|\n| `a.fft[n]` | Значение частотного диапазона (0-1) |\n| `a.show()` | Показать визуализацию FFT |\n| `a.hide()` | Скрыть визуализацию |\n| `a.setBins(n)` | Установить количество частотных диапазонов |\n| `a.setSmooth(n)` | Установить сглаживание (0-1) |\n| `a.setScale(n)` | Установить чувствительность |\n| `a.setCutoff(n)` | Установить порог шума |\n\n---\n\n## Базовый пример\n\n---\n\n## Разные частоты — разные параметры\n\n---\n\n## Модуляция громкостью\n\n---\n\n## Пульсирующий калейдоскоп\n\n---\n\n## Реактивный шум\n\n---\n\n## Feedback с аудио\n\n---\n\n## Паттерны Strudel в Hydra\n\nФункция `H()` позволяет использовать Strudel паттерны как входные значения для Hydra:\n\n---\n\n## feedStrudel — визуализация паттерна\n\n---\n\n## Советы по аудио-реактивности\n\n### Оптимальные настройки\n\n```javascript\na.setBins(4)       // Достаточно для bass/mid/high\na.setSmooth(0.8)   // Плавные переходы\na.setScale(8)      // Хорошая чувствительность\na.setCutoff(0.1)   // Отсечение шума\n```\n\n### Частотные диапазоны\n\n| Индекс | Частоты | Применение |\n|--------|---------|------------|\n| `a.fft[0]` | Низкие (басы) | Пульсация, масштаб |\n| `a.fft[1]` | Нижние средние | Вращение |\n| `a.fft[2]` | Верхние средние | Цвет, яркость |\n| `a.fft[3]` | Высокие | Мелкие детали |\n\n### Избегайте хаоса\n\n```javascript\n// Плохо: слишком много реактивности\nosc(() => a.fft[0] * 100).out()\n\n// Лучше: умеренные значения с базой\nosc(() => a.fft[0] * 30 + 10).out()\n```",
    "category": "hydra",
    "keywords": [
      "аудио-реактивность",
      "show",
      "hide",
      "setbins",
      "setsmooth",
      "setscale",
      "setcutoff",
      "osc",
      "out",
      "hydra",
      "feedback",
      "strudel",
      "feedstrudel",
      "javascript",
      "bass",
      "high"
    ],
    "path": "hydra/audio.mdx"
  },
  {
    "id": "hydra-blending",
    "title": "Смешивание (Blending)",
    "content": "# Смешивание (Blending)\n\nФункции смешивания комбинируют **цвета** двух визуальных источников.\n\n## add() — Сложение\n\nСкладывает цветовые значения. Результат обычно светлее.\n\n---\n\n## mult() — Умножение\n\nУмножает цветовые значения. Результат обычно темнее.\n\n---\n\n## diff() — Разница\n\nВычисляет абсолютную разницу между цветами.\n\n---\n\n## blend() — Плавное смешивание\n\nЛинейно интерполирует между двумя источниками.\n\n---\n\n## layer() — Наложение слоёв\n\nНакладывает один источник поверх другого с учётом альфа-канала.\n\n---\n\n## mask() — Маскирование\n\nИспользует второй источник как маску прозрачности.\n\n---\n\n## Комплексные примеры\n\n### Многослойная композиция\n\n### Использование нескольких буферов\n\n### Цветовые переходы",
    "category": "hydra",
    "keywords": [
      "смешивание",
      "(blending)",
      "add",
      "mult",
      "diff",
      "blend",
      "layer",
      "mask",
      "blending"
    ],
    "path": "hydra/blending.mdx"
  },
  {
    "id": "hydra-examples",
    "title": "Галерея примеров",
    "content": "# Галерея примеров\n\nКоллекция готовых визуализаций для изучения и вдохновения.\n\n---\n\n## Базовые визуалы\n\n### Радужный осциллятор\n\n### Калейдоскопический шум\n\n### Пульсирующие формы\n\n---\n\n## Текстуры и паттерны\n\n### Мрамор\n\n### Вода\n\n### Огонь\n\n---\n\n## Геометрические эффекты\n\n### Зеркальный тоннель\n\n### Вращающиеся кольца\n\n### Мозаика\n\n---\n\n## Психоделические визуалы\n\n### Гипноз\n\n### Жидкий металл\n\n### Неоновые волны\n\n---\n\n## Анимированные паттерны\n\n### Дыхание\n\n### Глитч\n\n### Сердцебиение\n\n---\n\n## Визуалы со Strudel\n\n### Аудио-реактивный осциллятор\n\n### Паттерн-синхронизация\n\n---\n\n## Космический вихрь\n\n---\n\n## Многослойный визуал",
    "category": "hydra",
    "keywords": [
      "галерея",
      "примеров",
      "strudel"
    ],
    "path": "hydra/examples.mdx"
  },
  {
    "id": "hydra-external-sources",
    "title": "Внешние источники",
    "content": "# Внешние источники\n\nHydra позволяет использовать внешние медиа-источники: изображения, видео, веб-камеру и экран. Они загружаются в переменные `s0`, `s1`, `s2`, `s3`.\n\n## initImage() — Изображение\n\nЗагружает изображение по URL как источник для визуализации.\n\n```javascript\ns0.initImage(url)\n```\n\n**Поддерживаемые форматы:** `.jpeg`, `.jpg`, `.png`, `.bmp`, `.gif`, `.webp`\n\n---\n\n## initVideo() — Видео\n\nЗагружает видео файл по URL как источник.\n\n```javascript\ns0.initVideo(url)\n```\n\n**Поддерживаемые форматы:** `.mp4`, `.ogg`, `.webm`\n\n---\n\n## initCam() — Веб-камера\n\nИнициализирует видеопоток с веб-камеры.\n\n```javascript\ns0.initCam(index)\n```\n\n| Параметр | По умолчанию | Описание |\n|----------|--------------|----------|\n| index | 0 | Номер камеры (при нескольких) |\n\n---\n\n## initScreen() — Захват экрана\n\nЗахватывает содержимое экрана, окна или вкладки браузера.\n\n```javascript\ns0.initScreen()\n```\n\n---\n\n## Комплексный пример с музыкой\n\n---\n\n## Решение проблем CORS\n\nЕсли изображение или видео не загружается:\n\n1. Используйте сервисы с поддержкой CORS:\n   - Wikimedia Commons\n   - Imgur\n   - Giphy\n\n2. Для YouTube/Vimeo используйте `initScreen()` для захвата окна браузера",
    "category": "hydra",
    "keywords": [
      "внешние",
      "источники",
      "initimage",
      "initvideo",
      "initcam",
      "initscreen",
      "hydra",
      "javascript",
      "jpeg",
      "webp",
      "webm",
      "index",
      "cors",
      "wikimedia",
      "commons",
      "imgur",
      "giphy",
      "youtube",
      "vimeo"
    ],
    "path": "hydra/external-sources.mdx"
  },
  {
    "id": "hydra-feedback",
    "title": "Feedback эффекты",
    "content": "# Feedback эффекты\n\nFeedback (обратная связь) — когда выход используется как вход, создавая эффект бесконечного зеркала.\n\n## Базовый Feedback\n\n### Feedback с масштабированием\n\n### Feedback с вращением\n\n---\n\n## Структура Feedback патча\n\n```javascript\nsrc(o0)                    // 1. Берём предыдущий кадр\n  .scale(1.01)             // 2. Применяем трансформацию\n  .rotate(0.01)\n  .blend(source, amount)    // 3. Смешиваем с новым источником\n  .out()                    // 4. Выводим\n```\n\n---\n\n## Техники Feedback\n\n### Бесконечный тоннель\n\n### Спиральный feedback\n\n### Feedback с модуляцией\n\n---\n\n## Перекрёстный Feedback\n\n---\n\n## Управление интенсивностью\n\n### Затухание feedback\n\n### Цветовой сдвиг\n\n---\n\n## Комплексные примеры\n\n### Психоделический feedback\n\n### Глитч feedback\n\n### Органический рост\n\n---\n\n## Советы по Feedback\n\n1. **Начинайте с малых значений** (scale: 1.01, rotate: 0.01)\n2. **Добавляйте затухание** (brightness: -0.005)\n3. **Используйте blend для контроля** (0.05-0.3)\n4. **Очистка экрана**: `solid(0, 0, 0).out()` если \"взорвалось\" белым",
    "category": "hydra",
    "keywords": [
      "feedback",
      "эффекты",
      "src",
      "scale",
      "rotate",
      "blend",
      "out",
      "solid",
      "javascript",
      "source",
      "amount",
      "brightness"
    ],
    "path": "hydra/feedback.mdx"
  },
  {
    "id": "hydra-intro",
    "title": "Введение в Hydra",
    "content": "# Введение в Hydra\n\n**Hydra** — это live-кодируемый видеосинтезатор, который работает прямо в браузере. Инструмент создан художницей Olivia Jack и вдохновлён аналоговыми модульными видеосинтезаторами.\n\n## Что такое Hydra?\n\nHydra позволяет создавать визуальные эффекты в реальном времени с помощью простого JavaScript кода. Синтаксис вдохновлён модульным синтезом — вместо физических кабелей вы соединяете JavaScript-функции через точки.\n\n### Простейший пример\n\n## Принцип модульного синтеза\n\n```\nИСТОЧНИК → ТРАНСФОРМАЦИИ → ВЫХОД\nsource   →    transforms   → .out()\n```\n\nЧисловые аргументы внутри функций аналогичны положению ручек на модулях синтезатора.\n\n## Пять типов функций\n\n### 1. Sources (Источники)\nГенерируют визуальный сигнал: `osc()`, `noise()`, `shape()`, `voronoi()`, `gradient()`, `solid()`\n\n### 2. Geometry (Геометрия)\nТрансформируют координаты: `rotate()`, `scale()`, `pixelate()`, `kaleid()`, `repeat()`\n\n### 3. Color (Цвет)\nИзменяют цветовые значения: `color()`, `brightness()`, `contrast()`, `saturate()`, `hue()`, `invert()`\n\n### 4. Blend (Смешивание)\nКомбинируют два источника: `add()`, `mult()`, `diff()`, `blend()`, `layer()`, `mask()`\n\n### 5. Modulate (Модуляция)\nИспользуют один источник для искажения геометрии другого: `modulate()`, `modulateScale()`, `modulateRotate()`\n\n## Выходные буферы\n\nHydra имеет **четыре выходных буфера**: `o0`, `o1`, `o2`, `o3`\n\n## Динамические параметры\n\nЛюбой параметр может быть функцией, которая вычисляется в реальном времени:\n\n## Следующие шаги\n\nИзучите детально каждый аспект Hydra:\n- [Источники](/hydra/sources) — все генераторы визуалов\n- [Трансформации](/hydra/transforms) — геометрия и цвет\n- [Смешивание](/hydra/blending) — комбинирование источников\n- [Модуляция](/hydra/modulation) — продвинутые эффекты\n- [Аудио-реактивность](/hydra/audio) — визуализация звука",
    "category": "hydra",
    "keywords": [
      "введение",
      "hydra",
      "out",
      "osc",
      "noise",
      "shape",
      "voronoi",
      "gradient",
      "solid",
      "rotate",
      "scale",
      "pixelate",
      "kaleid",
      "repeat",
      "color",
      "brightness",
      "contrast",
      "saturate",
      "hue",
      "invert"
    ],
    "path": "hydra/intro.mdx"
  },
  {
    "id": "hydra-modulation",
    "title": "Модуляция (Modulate)",
    "content": "# Модуляция (Modulate)\n\nМодуляция — одна из самых мощных техник в Hydra. Она использует цвета одного источника для **искажения геометрии** другого.\n\n## Как работает модуляция\n\nПри модуляции:\n- Красный канал модулятора → смещение по оси X\n- Зелёный канал модулятора → смещение по оси Y\n- Светлые области искажаются сильнее\n\n---\n\n## modulate() — Базовая модуляция\n\n```javascript\nsource.modulate(texture, amount)\n```\n\n---\n\n## modulateScale() — Модуляция масштаба\n\nИзменяет масштаб разных частей изображения.\n\n---\n\n## modulateRotate() — Модуляция вращения\n\nПрименяет разное количество вращения к разным частям изображения.\n\n---\n\n## modulateHue() — Модуляция оттенка\n\n---\n\n## modulateKaleid() — Модуляция калейдоскопа\n\n---\n\n## modulateRepeat() — Модуляция повторения\n\n---\n\n## modulatePixelate()\n\n---\n\n## Комплексные примеры\n\n### Многослойная модуляция\n\n### Самомодуляция (feedback)\n\n### Перекрёстная модуляция\n\n### Комбинация с цветом\n\n---\n\n## Советы по модуляции\n\n1. **Начинайте с малых значений** (0.1-0.3)\n2. **Используйте noise() как модулятор** — создаёт органичные искажения\n3. **Комбинируйте с цветовыми эффектами**\n4. **Анимируйте интенсивность**: `() => Math.sin(time) * 0.3`",
    "category": "hydra",
    "keywords": [
      "модуляция",
      "(modulate)",
      "modulate",
      "modulatescale",
      "modulaterotate",
      "modulatehue",
      "modulatekaleid",
      "modulaterepeat",
      "modulatepixelate",
      "noise",
      "sin",
      "hydra",
      "javascript",
      "source",
      "texture",
      "amount",
      "feedback",
      "math",
      "time"
    ],
    "path": "hydra/modulation.mdx"
  },
  {
    "id": "hydra-sources",
    "title": "Источники (Sources)",
    "content": "# Источники (Sources)\n\nИсточники — это функции, которые **генерируют** визуальный сигнал. Они являются отправной точкой любого визуала в Hydra.\n\n## osc() — Осциллятор\n\nСоздаёт полосатый паттерн, похожий на сигнал осциллятора.\n\n```javascript\nosc(frequency, sync, offset)\n```\n\n| Параметр | По умолчанию | Описание |\n|----------|--------------|----------|\n| frequency | 60 | Частота полос |\n| sync | 0.1 | Скорость движения |\n| offset | 0 | Цветовое смещение |\n\n---\n\n## noise() — Шум Перлина\n\nГенерирует органичный шумовой паттерн.\n\n```javascript\nnoise(scale, offset)\n```\n\n| Параметр | По умолчанию | Описание |\n|----------|--------------|----------|\n| scale | 10 | Масштаб шума |\n| offset | 0.1 | Скорость анимации |\n\n---\n\n## shape() — Геометрические фигуры\n\nСоздаёт правильные многоугольники.\n\n```javascript\nshape(sides, radius, smoothing)\n```\n\n| Параметр | По умолчанию | Описание |\n|----------|--------------|----------|\n| sides | 3 | Количество сторон |\n| radius | 0.3 | Размер фигуры (0-1) |\n| smoothing | 0.01 | Размытие краёв |\n\n---\n\n## voronoi() — Диаграмма Вороного\n\nСоздаёт клеточный паттерн.\n\n```javascript\nvoronoi(scale, speed, blending)\n```\n\n| Параметр | По умолчанию | Описание |\n|----------|--------------|----------|\n| scale | 5 | Количество ячеек |\n| speed | 0.3 | Скорость движения |\n| blending | 0.3 | Смешивание цветов |\n\n---\n\n## gradient() — Градиент\n\nСоздаёт цветовой градиент.\n\n```javascript\ngradient(speed)\n```\n\n---\n\n## solid() — Сплошной цвет\n\nСоздаёт однотонный цветовой фон.\n\n```javascript\nsolid(r, g, b, a)\n```\n\n---\n\n## src() — Внешний источник\n\nИспользует входные источники (`s0-s3`) или выходные буферы (`o0-o3`).\n\n---\n\n## Комбинирование источников\n\nИсточники можно комбинировать с помощью функций смешивания:",
    "category": "hydra",
    "keywords": [
      "источники",
      "(sources)",
      "osc",
      "noise",
      "shape",
      "voronoi",
      "gradient",
      "solid",
      "src",
      "sources",
      "hydra",
      "javascript",
      "frequency",
      "sync",
      "offset",
      "scale",
      "sides",
      "radius",
      "smoothing",
      "speed"
    ],
    "path": "hydra/sources.mdx"
  },
  {
    "id": "hydra-transforms",
    "title": "Трансформации",
    "content": "# Трансформации\n\nТрансформации изменяют визуальный сигнал после его создания источником. Делятся на **геометрические** и **цветовые**.\n\n## Геометрические трансформации\n\n### rotate() — Вращение\n\n```javascript\nrotate(angle, speed)\n```\n\n---\n\n### scale() — Масштабирование\n\n```javascript\nscale(amount, xMult, yMult, offsetX, offsetY)\n```\n\n---\n\n### pixelate() — Пикселизация\n\n```javascript\npixelate(pixelX, pixelY)\n```\n\n---\n\n### kaleid() — Калейдоскоп\n\n```javascript\nkaleid(nSides)\n```\n\n---\n\n### repeat() — Повторение\n\n```javascript\nrepeat(repeatX, repeatY, offsetX, offsetY)\n```\n\n---\n\n### scroll() — Прокрутка\n\n```javascript\nscrollX(scrollX, speed)\nscrollY(scrollY, speed)\n```\n\n---\n\n## Цветовые трансформации\n\n### color() — Установка цвета\n\n```javascript\ncolor(r, g, b, a)\n```\n\n---\n\n### brightness() и contrast()\n\n---\n\n### saturate() — Насыщенность\n\n---\n\n### hue() — Сдвиг оттенка\n\n---\n\n### invert() — Инверсия\n\n---\n\n### thresh() — Пороговая обработка\n\n---\n\n### posterize() — Постеризация\n\n---\n\n### colorama() — Цветовой сдвиг\n\n---\n\n## Комбинирование трансформаций\n\nТрансформации можно объединять в цепочки:",
    "category": "hydra",
    "keywords": [
      "трансформации",
      "rotate",
      "scale",
      "pixelate",
      "kaleid",
      "repeat",
      "scroll",
      "scrollx",
      "scrolly",
      "color",
      "brightness",
      "contrast",
      "saturate",
      "hue",
      "invert",
      "thresh",
      "posterize",
      "colorama",
      "javascript",
      "angle"
    ],
    "path": "hydra/transforms.mdx"
  },
  {
    "id": "hydra-tutorial",
    "title": "Интерактивный туториал Hydra",
    "content": "# Интерактивный туториал Hydra\n\nДобро пожаловать в пошаговый туториал по Hydra! Каждый пример можно редактировать и запускать прямо здесь.\n\n---\n\n## Шаг 1: Ваш первый визуал\n\nНачнём с самого простого — создадим осциллятор. Нажмите **play** чтобы увидеть результат:\n\n**Попробуйте:** Измените число внутри `osc()` на 10, 50 или 100 и посмотрите что изменится!\n\n---\n\n## Шаг 2: Параметры осциллятора\n\nОсциллятор `osc()` принимает три параметра:\n- **frequency** — частота полос\n- **sync** — скорость движения\n- **offset** — цветовое смещение\n\n**Попробуйте:**\n- Измените первое число (частота): 5, 20, 60\n- Измените третье число (цвет): 0, 0.5, 1.5\n\n---\n\n## Шаг 3: Добавляем трансформации\n\nТеперь добавим трансформацию — вращение с помощью `.rotate()`:\n\n**Попробуйте:** Измените число в rotate() на 0, 1, 2, 3.14\n\n---\n\n## Шаг 4: Калейдоскоп\n\nДобавим калейдоскопический эффект с помощью `.kaleid()`:\n\n**Попробуйте:** Измените число в kaleid() на 3, 6, 8, 12\n\n---\n\n## Шаг 5: Анимация со временем\n\nСделаем визуал динамичным! Используем функцию с `time`:\n\n**Ключевой момент:** `() => time * 0.1` — это функция, которая вычисляется каждый кадр. `time` — секунды с начала.\n\n---\n\n## Шаг 6: Другие источники — шум\n\nПопробуем другой источник — `noise()` (шум Перлина):\n\n---\n\n## Шаг 7: Добавляем цвет\n\nОкрасим шум с помощью `.color()`:\n\n**Попробуйте:**\n- Красный: `.color(1, 0, 0)`\n- Синий: `.color(0, 0, 1)`\n- Пурпурный: `.color(1, 0, 1)`\n\n---\n\n## Шаг 8: Геометрические фигуры\n\nИсточник `shape()` создаёт полигоны:\n\n---\n\n## Шаг 9: Сетка фигур\n\nДобавим повторение с помощью `.repeat()`:\n\n---\n\n## Шаг 10: Смешивание источников\n\nСмешаем два источника с помощью `.blend()`:\n\n---\n\n## Шаг 11: Разница (diff)\n\nВычислим разницу между двумя источниками:\n\n---\n\n## Шаг 12: Модуляция — магия искажений!\n\nМодуляция — самое интересное! Один источник искажает другой:\n\n**Попробуйте:** Измените второе число в modulate() от 0.1 до 1.0\n\n---\n\n## Шаг 13: Модуляция осциллятором\n\nПопробуем другой модулятор:\n\n---\n\n## Шаг 14: Комбинируем всё вместе\n\nТеперь создадим сложный визуал:\n\n---\n\n## Шаг 15: Feedback — бесконечность!\n\nFeedback создаёт эффект бесконечного зеркала:\n\n---\n\n## Шаг 16: Массивы для анимации\n\nМассивы автоматически переключают значения:\n\n---\n\n## Шаг 17: Плавные переходы\n\nДобавим `.smooth()` для плавных переходов:\n\n---\n\n## Шаг 18: Аудио-реактивность\n\nПодключим визуал к звуку:\n\n---\n\n## Шаг 19: Паттерны Strudel в Hydra\n\nФункция `H()` связывает Strudel паттерны с Hydra:\n\n---\n\n## Шаг 20: Ваш первый шедевр!\n\nТеперь вы знаете основы! Вот финальный пример — редактируйте его как хотите:\n\n---\n\n## Что дальше?\n\nПоздравляю! Теперь вы знаете основы Hydra. Продолжайте изучение:\n\n- [Источники](/hydra/sources) — все генераторы визуалов\n- [Модуляция](/hydra/modulation) — продвинутые техники искажения\n- [Галерея примеров](/hydra/examples) — вдохновляющие работы\n- [API Reference](/hydra/api) — полный справочник функций\n\n**Совет:** Экспериментируйте! Меняйте числа, комбинируйте функции, ошибайтесь — так рождается искусство!",
    "category": "hydra",
    "keywords": [
      "интерактивный",
      "туториал",
      "hydra",
      "osc",
      "rotate",
      "kaleid",
      "noise",
      "color",
      "shape",
      "repeat",
      "blend",
      "modulate",
      "smooth",
      "play",
      "frequency",
      "sync",
      "offset",
      "time",
      "diff",
      "feedback"
    ],
    "path": "hydra/tutorial.mdx"
  },
  {
    "id": "intro-gallery",
    "title": "Галерея треков",
    "content": "# Галерея треков от сообщества\n\nЛучшие треки и каверы от сообщества Strudel. Нажмите play!\n\n---\n\n## Почему я? — Nerual Dreming\n\n---\n\n## Love Again — Nerual Dreming\n\n---\n\n## Charli XCX - 360 (cover / remix) — KAIXI\n\n---\n\n## Grimes - Music 4 Machines (cover) — KAIXI\n\n---\n\n## Birds of a Feather — Billie Eilish (saga_3k)\n\n---\n\n## Determination — Undertale (Claffystic)\n\n---\n\n## Blue Monday — New Order\n\n---\n\n## Stranger Things Theme\n\n---\n\n## The Rhythm of the Night — Corona\n\n---\n\n## Waltz No. 2 — Шостакович\n\n---\n\n## Endless Tarantella\n\n---\n\n## Enjoy The Silence — Depeche Mode\n\n---\n\n## Pump Up The Jam — Technotronic\n\n---\n\n## Pyramid Song — Radiohead\n\n---\n\n## Amelie Waltz\n\n---\n\n## Happy Birthday\n\n---\n\n## Satiesfaction — Satie\n\n---\n\n## Shanghai — King Gizzard\n\n---\n\n## Clubbed\n\n---\n\n## Human Performance — Parquet Courts\n\n---\n\n## Cabinet — Spratleys Japs\n\n---\n\n## Ресурсы сообщества\n\n### Прямые ссылки на треки\n| Трек | Автор | Ссылка |\n|------|-------|--------|\n| Grimes – Music 4 Machines | KAIXI | [открыть](https://strudel.cc/?sOc7cVTqJHUU) |\n| Charli XCX – 360 | KAIXI | [открыть](https://strudel.cc/?2ErYTSUotoaQ) |\n| Radiohead – Pyramid Song | eefano | [открыть](https://strudel.cc/?MeMCjUtlCAoK) |\n| Billie Eilish – Birds of a Feather | saga_3k | [открыть](https://strudel.cc/?yTnr825wyd9V) |\n| Shostakovich – Waltz No.2 | eefano | [открыть](https://strudel.cc/?o2VwC4Jq66XI) |\n\n### Коллекции\n- [eefano/strudel-songs-collection](https://github.com/eefano/strudel-songs-collection) — 75+ каверов\n- [awesome-strudel](https://github.com/terryds/awesome-strudel) — курируемая коллекция",
    "category": "intro",
    "keywords": [
      "галерея",
      "треков",
      "strudel",
      "play",
      "nerual",
      "dreming",
      "love",
      "again",
      "charli",
      "cover",
      "remix",
      "kaixi",
      "grimes",
      "music",
      "machines",
      "birds",
      "feather",
      "billie",
      "eilish",
      "determination"
    ],
    "path": "intro/gallery.mdx"
  },
  {
    "id": "intro-showcase",
    "title": "Витрина",
    "content": "# Витрина\n\nЭта страница содержит случайную подборку видео, показывающих людей, использующих strudel тем или иным способом.",
    "category": "intro",
    "keywords": [
      "витрина",
      "strudel"
    ],
    "path": "intro/showcase.mdx"
  },
  {
    "id": "learn-accumulation",
    "title": "Модификаторы накопления",
    "content": "# Модификаторы накопления\n\n## superimpose\n\n## layer\n\n## off\n\n## echo\n\n## echoWith\n\n## stut\n\nТакже есть [Тональные функции](/learn/tonal).",
    "category": "learn",
    "keywords": [
      "модификаторы",
      "накопления",
      "superimpose",
      "layer",
      "echo",
      "echowith",
      "stut",
      "learn",
      "tonal"
    ],
    "path": "learn/accumulation.mdx"
  },
  {
    "id": "learn-advanced-integrations",
    "title": "Продвинутые интеграции",
    "content": "# Продвинутые интеграции\n\nЭта страница описывает продвинутые техники интеграции Bulka с внешними инструментами и системами.\n\n## Hydra — продвинутые техники\n\n### Синхронизация паттернов с визуалами\n\nФункция `H()` позволяет использовать музыкальные паттерны как входные данные для Hydra:\n\n### Трансформация встроенных визуализаций\n\nС `feedStrudel` можно применять эффекты Hydra к pianoroll, scope и другим:\n\n### Реакция на аудио\n\nС `detectAudio` Hydra реагирует на звук через FFT анализ:\n\n## MIDI — продвинутые техники\n\n### Паттернирование Control Change\n\nМодулируйте параметры внешних синтезаторов с помощью CC:\n\n### Мультиканальный MIDI\n\nОтправляйте разные паттерны на разные MIDI каналы:\n\n### Pitch Bend и модуляция\n\n### MIDI Input — использование контроллеров\n\n```javascript\n// Подключение к MIDI входу\nlet cc = await midin('Your MIDI Device')\n\n// Используем CC контроллеры для управления\nnote(\"c3 e3 g3 b3\")\n  .lpf(cc(74).range(100, 5000))  // CC 74 → фильтр\n  .lpq(cc(71).range(0, 20))      // CC 71 → резонанс\n  .gain(cc(7).range(0, 1))       // CC 7 → громкость\n  .s(\"sawtooth\")\n```\n\n## OSC и SuperCollider\n\n### Настройка подключения\n\n```bash\n# Установите и запустите OSC мост\nnpx @strudel/osc\n\n# С отладкой для проверки сообщений\nnpx @strudel/osc --debug\n```\n\n### Отправка в SuperDirt\n\n### Орбиты для раздельной обработки\n\nВ SuperDirt разные орбиты имеют независимые эффекты:\n\n## Геймпад\n\nУправляйте паттернами с помощью геймпада:\n\n## Flok — совместный live coding\n\n[Flok](https://flok.cc/) позволяет нескольким людям кодить вместе:\n\n1. Откройте flok.cc\n2. Создайте сессию\n3. Поделитесь ссылкой с другими\n4. Один кодит звук (Strudel), другой — визуалы (Hydra)\n\n```javascript\n// Участник 1 — звук\n$: s(\"bd*4, hh*8\")\n$: note(\"[c3,e3,g3]\").s(\"sawtooth\").lpf(800)\n\n// Участник 2 — визуалы\nosc(10).rotate(0.1).out()\n```\n\n## Hydra-Strudel расширение\n\nВнешнее расширение для ещё более тесной интеграции:\n\n```javascript\n// Загрузка расширения\nawait loadScript(\"https://cdn.jsdelivr.net/gh/atfornes/Hydra-strudel-extension@latest/hydra-strudel.js\")\nawait initHydraStrudel()\n\n// Один паттерн для звука и визуализации\nmyPattern = '0 10 [2 5]*4'.slow(2)\nnote(myPattern).play()      // Аудио\nosc(P(myPattern)).out()     // Визуализация с функцией P()\n```\n\n## Практические советы\n\n### Производительность интеграций\n\n- **Hydra**: Сложные шейдеры нагружают GPU. Начинайте с простого.\n- **MIDI**: Web MIDI имеет небольшую задержку. Для критичных применений используйте desktop версию.\n- **OSC**: Требует запущенного SuperCollider. Убедитесь, что SuperDirt загружен.\n\n### Отладка\n\n```javascript\n// Для OSC — запустите с --debug\n// npx @strudel/osc --debug\n\n// Для MIDI — проверьте доступные устройства\n// В консоли браузера: navigator.requestMIDIAccess()\n```\n\n### Комбинирование интеграций\n\nМожно использовать несколько интеграций одновременно:\n\n---\n\n*Для более детальной информации о каждой интеграции смотрите соответствующие страницы документации.*",
    "category": "learn",
    "keywords": [
      "продвинутые",
      "интеграции",
      "midin",
      "note",
      "lpf",
      "cc",
      "range",
      "lpq",
      "gain",
      "osc",
      "rotate",
      "out",
      "loadscript",
      "inithydrastrudel",
      "slow",
      "play",
      "requestmidiaccess",
      "bulka",
      "hydra",
      "feedstrudel"
    ],
    "path": "learn/advanced-integrations.mdx"
  },
  {
    "id": "learn-ai-agent",
    "title": "Bulka AI Agent",
    "content": "# Bulka AI Agent\n\nBulka AI — это встроенный музыкальный помощник, который поможет тебе создавать музыку через код. Агент понимает Strudel/TidalCycles и может писать, редактировать и запускать код за тебя.\n\n## Особенности\n\n- **Три провайдера на выбор**: OpenAI, Anthropic (Claude), Google Gemini\n- **Полный real-time стриминг**: ответы появляются в реальном времени\n- **Отображение мыслей**: для Claude 4+ и Gemini 2.5+ показывается процесс размышления\n- **Динамическая загрузка моделей**: список моделей подгружается напрямую с API провайдеров\n- **Работа с выделением**: выдели код — агент сфокусируется на нём\n- **Поиск по документации**: агент знает Strudel и может искать в справочнике\n\n## Где найти агента?\n\nAI-агент находится в правой панели редактора. Открой вкладку **Chat** (иконка чата) в боковой панели справа от редактора кода.\n\n## Настройка API ключа\n\nДля работы агента нужен API ключ от одного из провайдеров:\n\n1. Открой вкладку **Chat** в боковой панели\n2. Если ключ не настроен — автоматически откроется панель настроек\n3. Выбери провайдера:\n   - **OpenAI** — GPT-4o, GPT-5\n   - **Anthropic** — Claude Sonnet 4.5, Claude Opus 4\n   - **Google Gemini** — Gemini 2.5 Pro, Gemini 2.5 Flash\n4. Введи свой API ключ\n5. Нажми **Сохранить**\n\n### Где получить API ключ?\n\n- **OpenAI**: [platform.openai.com/api-keys](https://platform.openai.com/api-keys)\n- **Anthropic**: [console.anthropic.com](https://console.anthropic.com/)\n- **Google Gemini**: [aistudio.google.com/apikey](https://aistudio.google.com/apikey)\n\nВсе ключи хранятся только локально в твоём браузере.\n\n## Поддерживаемые модели\n\n### OpenAI\n- **GPT-4o** — быстрая и умная модель\n- **GPT-4o Mini** — экономичная версия\n- **GPT-5** — самая мощная модель (если доступна)\n\n### Anthropic (Claude)\n- **Claude Sonnet 4.5** — отличный баланс скорости и качества\n- **Claude Opus 4** — максимальное качество\n- **Claude 3.5 Haiku** — быстрая версия\n\n### Google Gemini\n- **Gemini 2.5 Pro** — мощная модель с thinking\n- **Gemini 2.5 Flash** — быстрая и экономичная\n\n## Что умеет агент?\n\n### Создание музыки\nПросто опиши что хочешь создать:\n- \"Создай простой бит с бочкой и снейром\"\n- \"Сделай расслабляющий эмбиент трек\"\n- \"Напиши драм-н-бейс паттерн на 174 BPM\"\n\n### Редактирование кода\nАгент может изменять существующий код:\n- \"Добавь бас к текущему треку\"\n- \"Сделай хай-хэты быстрее\"\n- \"Добавь реверберацию на все инструменты\"\n\n### Объяснение кода\nЕсли непонятно что делает код:\n- \"Объясни что делает текущий код\"\n- \"Что означает .lpf(800)?\"\n\n### Работа с выделением\nВыдели часть кода в редакторе, и агент будет работать только с этим фрагментом:\n- \"Измени этот фрагмент\"\n- \"Добавь эффект к выделенному\"\n\n### Поиск в коде\nАгент может найти и выделить нужный фрагмент:\n- \"Покажи где регулируется громкость\"\n- \"Найди где определён бас\"\n\n### Визуализация Hydra\nАгент умеет добавлять визуализации:\n- \"Добавь Hydra визуализацию\"\n- \"Сделай визуал синхронизированный с музыкой\"\n\n## Инструменты агента\n\nАгент использует специальные инструменты для работы с редактором:\n\n| Инструмент | Описание |\n|------------|----------|\n| `readCode()` | Прочитать текущий код из редактора |\n| `setFullCode(code)` | Заменить весь код (для нового трека) |\n| `editCode(search, replace)` | Найти и заменить фрагмент кода |\n| `appendCode(code)` | Добавить код в конец |\n| `playMusic()` | Запустить воспроизведение |\n| `stopMusic()` | Остановить воспроизведение |\n| `searchDocs(query)` | Поиск по документации Strudel |\n| `highlightCode(search)` | Выделить фрагмент кода в редакторе |\n\n## Быстрые команды\n\nВ чате есть кнопки быстрых команд:\n- **Простой бит** — создать базовый ритм\n- **Добавь бас** — добавить басовую линию\n- **Объясни код** — получить объяснение текущего кода\n- **Добавь эффект** — добавить реверберацию и задержку\n\n## Отправка ошибок в чат\n\nЕсли возникла ошибка, на плашке ошибки есть кнопка **\"В чат\"** — нажми её, и агент получит описание ошибки и поможет исправить.\n\n## Советы по использованию\n\n### Будь конкретным\nЧем точнее описание, тем лучше результат:\n- ❌ \"Сделай что-нибудь\"\n- ✅ \"Создай минималистичный техно бит в 120 BPM с глубоким басом\"\n\n### Используй выделение\nВыдели код который хочешь изменить — агент сфокусируется на нём.\n\n### Итерируй\nНе пытайся сделать всё сразу. Начни с простого и постепенно добавляй элементы.\n\n### Сообщай об ошибках\nЕсли что-то звучит не так — скажи об этом. Агент исправит.\n\n## Пример диалога\n\n**Ты:** Создай простой хаус бит\n\n**Агент:** *создаёт код и запускает*\n\n```javascript\n// === ХАУС БИТ ===\nstack(\n  s(\"bd*4\").gain(0.9)._scope(),           // бочка на каждую долю\n  s(\"~ cp ~ cp\").gain(0.7),               // хлопок на 2 и 4\n  s(\"hh*8\").gain(0.5)._scope(),           // хай-хэты\n  note(\"c2 c2 c2 c3\").s(\"bass\").lpf(600)  // басовая линия\n)\n```\n\n**Ты:** Добавь пианино\n\n**Агент:** *редактирует код, добавляет пианино*\n\n**Ты:** Сделай бас глубже\n\n**Агент:** *находит бас и понижает фильтр*\n\n## Ограничения\n\n- Агент видит только код, но не слышит результат\n- При ошибках — опиши что пошло не так\n- Сложные многослойные треки лучше строить постепенно\n- Агент работает только с Strudel/TidalCycles синтаксисом\n\n## Приватность\n\n- API ключи хранятся только в localStorage твоего браузера\n- Код и сообщения отправляются напрямую провайдеру (OpenAI/Anthropic/Google)\n- Bulka не сохраняет твои данные на своих серверах",
    "category": "learn",
    "keywords": [
      "bulka",
      "agent",
      "lpf",
      "readcode",
      "setfullcode",
      "editcode",
      "appendcode",
      "playmusic",
      "stopmusic",
      "searchdocs",
      "highlightcode",
      "stack",
      "gain",
      "note",
      "strudel",
      "tidalcycles",
      "openai",
      "anthropic",
      "claude",
      "google"
    ],
    "path": "learn/ai-agent.mdx"
  },
  {
    "id": "learn-code",
    "title": "Синтаксис кодирования",
    "content": "# Синтаксис кодирования\n\nДавайте сделаем шаг назад и разберемся, как работает синтаксис в Strudel.\n\nВзгляните на этот простой пример:\n\n- У нас есть слово `note`, за которым следуют скобки `()` с некоторыми словами/буквами/цифрами внутри, окруженными кавычками `\"c a f e\"`\n- Затем у нас есть точка `.`, за которой следует еще один похожий фрагмент кода `s(\"piano\")`.\n- Мы также видим, что эти тексты _подсвечены_ с использованием цветов: слово `note` фиолетовое, скобки `()` серые, а содержимое внутри `\"\"` зеленое. (Цвета могут отличаться, если вы изменили тему по умолчанию)\n\nЧто произойдет, если мы попытаемся \"сломать\" этот паттерн разными способами?\n\nХорошо, кажется, ни один из них не работает...\n\nЭтот работает, но теперь мы слышим только первую ноту...\n\nТак что же здесь происходит?\n\n# Функции, аргументы и цепочки\n\nДо сих пор мы видели следующий синтаксис:\n\n```\nxxx(\"foo\").yyy(\"bar\")\n```\n\nВ общем, `xxx` и `yyy` называются [_функциями_](<https://en.wikipedia.org/wiki/Function_(computer_programming)>), в то время как `foo` и `bar` называются [_аргументами_ или _параметрами_](<https://en.wikipedia.org/wiki/Parameter_(computer_programming)>) функции.\nДо сих пор мы использовали функции для объявления того, каким аспектом звука мы хотим управлять, а их аргументы - для фактических данных.\nФункция `yyy` называется [_цепной_ функцией](https://en.wikipedia.org/wiki/Method_chaining), потому что перед ней стоит точка (`.`).\n\nВ общем, идея цепочек заключается в том, что код вроде `a(\"this\").b(\"that\").c(\"other\")` позволяет функциям `a`, `b` и `c` выполняться в определенном порядке, без необходимости писать их как три отдельные строки кода.\nВы можете думать об этом как о соединении аудиоэффектов вместе с помощью гитарных педалей или цифровых аудиоэффектов.\n\nStrudel активно использует цепные функции. Вот более сложный пример:\n\n## Напишите свою собственную цепную функцию\n\nВы можете написать свою собственную цепную функцию, используя `register`. Вот приведенная выше цепочка, зарегистрированная как переиспользуемая цепная функция.\n\nПопробуйте добавить `.rev()` после `effectChain()`, чтобы услышать дополнительные эффекты.\n\n# Комментарии\n\n`//` в приведенном выше примере - это строчный комментарий, в результате которого функция `delay` игнорируется.\nЭто удобный способ быстро включать и выключать код.\nПопробуйте раскомментировать эту строку, удалив `//` и обновив паттерн.\nВы также можете использовать сочетание клавиш `cmd-/` для переключения комментариев.\n\nВы могли заметить, что некоторые комментарии в примерах REPL содержат слова, начинающиеся с \"@\", например `@by` или `@license`.\nЭто всего лишь соглашение для определения некоторой информации о музыке. Мы поговорим об этом в разделе [Метаданные музыки](/learn/metadata).\n\n# Строки\n\nХорошо, а что насчет содержимого внутри кавычек (например, `\"c a f e\"`)?\nВ JavaScript, как и в большинстве языков программирования, это содержимое называется [_строкой_](<https://en.wikipedia.org/wiki/String_(computer_science)>).\nСтрока - это просто последовательность отдельных символов.\nВ TidalCycles строки в двойных кавычках используются для написания _patterns_ с использованием mini-notation, и время от времени вы можете услышать фразу _pattern string_.\nЕсли вы хотите создать обычную строку, а не паттерн, вы можете использовать одинарные кавычки, например, `'C minor'` не будет интерпретироваться как Mini Notation.\n\nХорошая новость в том, что это охватывает большую часть синтаксиса JavaScript, необходимого для Strudel!\n\n<br />",
    "category": "learn",
    "keywords": [
      "синтаксис",
      "кодирования",
      "xxx",
      "yyy",
      "rev",
      "effectchain",
      "strudel",
      "note",
      "piano",
      "https",
      "wikipedia",
      "wiki",
      "this",
      "that",
      "other",
      "register",
      "delay",
      "repl",
      "license",
      "learn"
    ],
    "path": "learn/code.mdx"
  },
  {
    "id": "learn-colors",
    "title": "Цвета",
    "content": "# Цвета",
    "category": "learn",
    "keywords": [
      "цвета"
    ],
    "path": "learn/colors.mdx"
  },
  {
    "id": "learn-community",
    "title": "Сообщество и ресурсы",
    "content": "# Сообщество и ресурсы\n\nЭта страница собирает полезные советы, примеры треков и ресурсы от сообщества Strudel/TidalCycles.\n\n## Где найти сообщество\n\n### Bulka (русскоязычное сообщество)\n\n- **Telegram**: [t.me/bulka_app](https://t.me/bulka_app) — русскоязычное сообщество Bulka\n- **Сайт**: [bulka.app](https://bulka.app/) — официальный сайт проекта\n- **GitHub**: [github.com/timoncool/Bulka](https://github.com/timoncool/Bulka) — исходный код проекта\n\n### Strudel/TidalCycles (международное сообщество)\n\n- **Discord**: [Tidal, Strudel and friends](https://discord.com/invite/HGEdXmRkzT) — 7000+ участников, активное сообщество\n- **Форум**: [club.tidalcycles.org](https://club.tidalcycles.org/) — обсуждения, вопросы, идеи\n- **Community Bakery**: [strudel.cc/bakery](https://strudel.cc/bakery/) — паттерны от других пользователей\n- **GitHub**: [awesome-strudel](https://github.com/terryds/awesome-strudel) — курируемая коллекция ресурсов\n\n## Советы и хитрости\n\n### Частые ошибки\n\n**`n` vs `note` — в чём разница?**\n\n- `note` изменяет высоту звука (pitch)\n- `n` выбирает номер sample из банка\n\nПри работе с синтезаторами оба меняют высоту, но с samples `n` выбирает файл!\n\n**Панель Reference замедляет работу**\n\nЕсли заметили тормоза — закройте панель Reference. Она рендерит много элементов и может влиять на производительность звука.\n\n**Звуки не загружаются с первого раза**\n\nSamples нужно загрузить — при первом запуске может быть тишина. Просто запустите код ещё раз.\n\n### Workflow советы\n\n**Используйте Community Bakery для вдохновения**\n\nОткрывайте [strudel.cc/bakery](https://strudel.cc/bakery/), изучайте паттерны других — это лучший способ учиться новым техникам.\n\n**Делитесь своим кодом**\n\nНажмите кнопку \"Share\" в REPL — получите ссылку на ваш паттерн, которой можно поделиться.\n\n**Не бойтесь удалять код**\n\nЕсли результат не нравится — удаляйте и начинайте заново. Это нормальная часть процесса live coding.\n\n## Примеры треков\n\n### Минимал техно\n\n### Эмбиент дрон\n\n### Драм-н-бейс паттерн\n\n### Полиритмический грув\n\n### Евклидовы ритмы\n\n### Acid bassline\n\n### Lo-fi хип-хоп\n\n## Продвинутые техники\n\n### Нарезка брейков (Breakbeat chopping)\n\n### Генеративные паттерны с rand\n\n### Layer для сложных текстур\n\n### Phasing (фазирование)\n\n### Conditional modifiers\n\n## YouTube туториалы\n\nРекомендуемые видео для изучения:\n\n- **\"Live Coding For Music With Strudel.cc (Beginners)\"** — Groovin in G, отличный старт для новичков\n- **\"Creative Code Art - WORKSHOP // Coding Music With Strudel\"** — Dan Gorelick & Viola He, полноценный воркшоп\n- **\"Intro To Algorave (Strudel Workshop)\"** — введение в культуру algorave\n- **Switch Angel** — канал с демонстрациями live coding техно\n\n## Полезные ресурсы\n\n### Документация\n- [strudel.cc](https://strudel.cc/) — официальный сайт\n- [TidalCycles Docs](https://tidalcycles.org/docs/) — документация оригинального Tidal (многое применимо)\n\n### Инструменты\n- **Flok** ([flok.cc](https://flok.cc/)) — совместный live coding в браузере\n- **strudel.nvim** — интеграция с Neovim для продвинутых пользователей\n\n### Семплы\n- [Dirt Samples](https://github.com/tidalcycles/dirt-samples) — стандартная библиотека\n- [Clean Breaks](https://github.com/yaxu/clean-breaks) — коллекция брейков\n\n## Оптимизация производительности\n\n- **Закрывайте панель Reference** при активном live coding\n- **Используйте `.cut(1)`** для samples, чтобы избежать наложения\n- **Desktop приложение** — экспериментальная версия через Tauri для лучшей производительности\n- **Ограничивайте reverb** — `.room()` и `.size()` с высокими значениями нагружают процессор\n\n## Философия live coding\n\n> «Не бойтесь ошибок — это часть процесса. Практикуйтесь как на музыкальном инструменте. Со временем станет лучше.»\n\nLive coding — это:\n- **Эксперимент** — пробуйте разное, слушайте что получается\n- **Процесс** — важен не только результат, но и путь к нему\n- **Сообщество** — делитесь, учитесь у других, задавайте вопросы\n\n---\n\n*Хотите добавить свой пример или совет? Создайте PR в репозитории проекта!*",
    "category": "learn",
    "keywords": [
      "сообщество",
      "ресурсы",
      "cut",
      "room",
      "size",
      "strudel",
      "tidalcycles",
      "bulka",
      "telegram",
      "https",
      "github",
      "timoncool",
      "discord",
      "tidal",
      "friends",
      "invite",
      "hgedxmrkzt",
      "club",
      "community",
      "bakery"
    ],
    "path": "learn/community.mdx"
  },
  {
    "id": "learn-conditional-modifiers",
    "title": "Условные модификаторы",
    "content": "# Условные модификаторы\n\n## lastOf\n\n## firstOf\n\n## when\n\n## chunk\n\n### chunkBack\n\n### fastChunk\n\n## arp\n\n## arpWith 🧪\n\n## struct\n\n## mask\n\n## reset\n\n## restart\n\n## hush\n\n## invert\n\n## pick\n\n## pickmod\n\n## pickF\n\n## pickmodF\n\n## pickRestart\n\n## pickmodRestart\n\n## pickReset\n\n## pickmodReset\n\n## inhabit\n\n## inhabitmod\n\n## squeeze\n\nПосле условных модификаторов давайте посмотрим, что могут предложить [Модификаторы накопления](/learn/accumulation).",
    "category": "learn",
    "keywords": [
      "условные",
      "модификаторы",
      "lastof",
      "firstof",
      "when",
      "chunk",
      "chunkback",
      "fastchunk",
      "arpwith",
      "struct",
      "mask",
      "reset",
      "restart",
      "hush",
      "invert",
      "pick",
      "pickmod",
      "pickf",
      "pickmodf",
      "pickrestart"
    ],
    "path": "learn/conditional-modifiers.mdx"
  },
  {
    "id": "learn-csound",
    "title": "Csound",
    "content": "# Использование CSound с Strudel\n\n🧪 Strudel имеет экспериментальную поддержку csound, используя [@csound/browser](https://www.npmjs.com/package/@csound/browser).\n\n## Импорт .orc файлов\n\nЧтобы использовать существующие инструменты csound, вы можете загрузить и использовать orc файл из URL следующим образом:\n\nОбратите внимание, что вышеуказанный URL использует сокращение `github:`, которое разрешается в raw файл на github, но вы можете использовать любой URL по вашему желанию.\n\nЗамечательный [`livecode.orc by Steven Yi`](https://github.com/kunstmusik/csound-live-code) поставляется с множеством готовых к использованию звуков:\n\n## Написание собственных инструментов\n\nВы можете определить свой собственный инструмент(ы) с помощью `loadCsound` следующим образом:\n\n## Параметры\n\nФункция `.csound` отправляет следующие p значения:\n\n|     |                                  |\n| --- | -------------------------------- |\n| p1  | имя инструмента, например `CoolSynth` |\n| p2  | смещение времени, когда он должен играть |\n| p3  | длительность события / hap  |\n| p4  | частота в герцах               |\n| p5  | нормализованный `gain`, 0-1           |\n\nСуществует альтернативная функция `.csoundm` с другим подходом:\n\n|     |                                   |\n| --- | --------------------------------- |\n| p4  | номер midi клавиши, неокругленный, 0-127 |\n| p5  | midi velocity, 0-127              |\n\nВ обоих случаях p4 получается из значения `freq` или `note`.\n\n## Ограничения / Планы на будущее\n\nПомимо перечисленных выше p значений, никакие другие параметры пока не могут быть использованы в pattern.\nЭто также означает, что [аудио эффекты](/learn/effects/) работать не будут.\nВ будущем интеграция может быть улучшена путем передачи всех параметров управления pattern в инструмент csound.\nЭто может работать через уникальный [channel](https://kunstmusik.github.io/icsc2022-csound-web/tutorial2-interacting-with-csound/#step-4---writing-continuous-data-channels)\nдля каждого значения. Каналы могут быть прочитаны [вот так](https://github.com/csound/csound/blob/master/Android/CsoundForAndroid/CsoundAndroidExamples/src/main/res/raw/multitouch_xy.csd).\nТакже может иметь смысл иметь стандартную библиотеку csound инструментов для эффектов strudel.\n\nТеперь давайте погрузимся в [Functional JavaScript API](/functions/intro)",
    "category": "learn",
    "keywords": [
      "csound",
      "strudel",
      "browser",
      "https",
      "npmjs",
      "package",
      "github",
      "livecode",
      "steven",
      "kunstmusik",
      "live",
      "code",
      "loadcsound",
      "coolsynth",
      "gain",
      "csoundm",
      "midi",
      "velocity",
      "freq",
      "note"
    ],
    "path": "learn/csound.mdx"
  },
  {
    "id": "learn-devicemotion",
    "title": "Движение устройства",
    "content": "",
    "category": "learn",
    "keywords": [
      "движение",
      "устройства"
    ],
    "path": "learn/devicemotion.mdx"
  },
  {
    "id": "learn-effects",
    "title": "Audio effects",
    "content": "# Audio Effects\n\nНезависимо от того, используете ли вы synth или sample, вы можете применить любой из следующих встроенных audio effects.\nКак вы могли догадаться, effects могут быть объединены в цепочку, и они принимают строку pattern в качестве аргумента.\n\n# Signal chain\n\n<img src=\"/img/strudel-signal-flow.png\"></img>\n\nSignal chain в Strudel выглядит следующим образом:\n\n- Звукогенерирующий event запускается pattern\n  - У него есть время начала и продолжительность, которые обычно\n    контролируются длиной ноты и параметрами ADSR\n  - Если мы превышаем максимальную полифонию, старые звуки начинают исчезать\n  - Заглушенные звуки (те, чье значение `s` равно `-`, `~` или `_`) пропускаются\n- Производится звук (через, скажем, sample или oscillator)\n  - Здесь происходят effects на основе detune (такие как `detune`, `penv` и т.д.)\n- Следующее произойдет _по порядку_ и только если они были вызваны в pattern. Обратите внимание, что все это\n  effects одноразового использования, что означает, что множественные вхождения их в pattern просто переопределят значения\n  (например, вы не можете сделать `s(\"bd\").lpf(100).distort(2).lpf(800)` для lowpass, distort, а затем снова lowpass)\n  - Phase vocoder (`stretch`)\n  - Применяется Gain (`gain`)\n    - Здесь происходит основной ADSR (громкости)\n  - Lowpass filter (`lpf`)\n  - Highpass filter (`hpf`)\n  - Bandpass filter (`bandpass`)\n  - Vowel filter (`vowel`)\n  - Уменьшение частоты дискретизации (`coarse`)\n  - Bit crushing (`crush`)\n  - Waveshape distortion (`shape`)\n  - Обычный distortion (`distort`)\n  - Tremolo (`tremolo`)\n  - Compressor (`compressor`)\n  - Panning (`pan`)\n  - Phaser (`phaser`)\n  - Postgain (`post`)\n- Затем звук разделяется на несколько назначений\n  - Dry output (количество контролируется параметром `dry`)\n  - The sends\n    - Analyzers\n      - Они используются для инструментов типа `scope` и `spectrum`, и их настройка обычно происходит за кулисами\n    - Delay (количество контролируется параметром `delay`)\n    - Reverb (количество контролируется параметром `room`)\n- Dry output, delay и reverb объединяются в так называемый \"orbit\" pattern (подробнее см. в разделе ниже)\n  - Effect `duck` влияет на громкость всех сигналов в orbit\n  - Затем orbit отправляется в микшер\n\n## Orbits\n\nOrbits — это способ обработки выходов в Strudel. Они также предписывают, какие delay и reverb связать с dry signal.\nПо умолчанию все orbits смешиваются в каналы `1` и `2` в стерео, однако с настройкой \"Multi Channel Orbits\"\n(в разделе Настройки справа) вы можете использовать их как отдельные 2-канальные стерео выходы (orbit `i` будет отображен на\nканалы `2i` и `2i + 1`). Затем вы можете использовать маршрутизаторы типа Blackhole 16 для получения и записи всех каналов в DAW для последующей обработки.\n\nOrbit по умолчанию — `1`, и он устанавливается с помощью `orbit`. Вы можете отправить звук на несколько orbits через mininotation\n\nно будьте осторожны, так как это создаст три копии звука за кулисами, что означает, что если они будут смешаны\nв один выход, они утроят громкость. Мы уменьшили gain здесь, чтобы сберечь ваши уши.\n\n⚠️ На каждый orbit приходится только один delay и один reverb, поэтому имейте в виду, что если вы попытаетесь изменить параметры на двух\npatterns, указывающих на один и тот же orbit, это может привести к непредсказуемым результатам. Сравните, например, этот красивый pluck\nс большим reverb:\n\nпротив того же pluck с заглушенным kick drum, который переопределяет значение `roomsize`:\n\nЭто происходит из-за того, что они используют один и тот же orbit: по умолчанию `1`. Это можно исправить, просто обновив orbits, чтобы они были\nразличными:\n\n## Непрерывные изменения\n\nПоскольку все вышеперечисленное запускается _при возникновении звука_, часто бывает так, что параметры могут не\nизменяться непрерывно во времени. Например,\n\nНе будет производить непрерывно модулированный LFO low-pass filter из-за того, что `tri` семплируется только каждый раз, когда звучит нота\n(в данном случае по умолчанию один раз за cycle). Вы можете имитировать это, введя больше звукогенерирующих events, например:\n\nНекоторые параметры _действительно_ вызывают непрерывные изменения во времени, хотя:\n\n- Кривая ADSR (управляется `attack`, `sustain`, `decay`, `release`)\n- Кривая pitch envelope (управляется `penv` и связанными ADSR)\n- Кривая FM (`fmenv`)\n- Filter envelopes (`lpenv`, `hpenv`, `bpenv`)\n- Tremolo (`tremolo`)\n- Phaser (`phaser`)\n- Vibrato (`vib`)\n- Ducking (`duckorbit`)\n\n# Filters\n\nFilters являются важным строительным блоком [subtractive synthesis](https://en.wikipedia.org/wiki/Subtractive_synthesis).\nStrudel поставляется с 3 типами filters:\n\n- low-pass filter: низкие частоты могут _пройти_, высокие частоты обрезаются\n- high-pass filter: высокие частоты могут _пройти_, низкие частоты обрезаются\n- band-pass filters: может _пройти_ только частотная полоса, низкие и высокие частоты вокруг обрезаются\n\nКаждый filter имеет 2 параметра:\n\n- cutoff: частота, на которой filter начинает работать. например, low-pass filter с cutoff 1000Hz позволяет частотам ниже 1000Hz проходить.\n- q-value: Контролирует резонанс filter. Более высокие значения звучат более агрессивно. См. также [Q-Factor](https://en.wikipedia.org/wiki/Q_factor)\n\n## lpf\n\n## lpq\n\n## hpf\n\n## hpq\n\n## bpf\n\n## bpq\n\n## ftype\n\n## vowel\n\n# Amplitude Modulation\n\nAmplitude modulation периодически изменяет амплитуду (gain) во времени.\n\n## am\n\n## tremolosync\n\n## tremolodepth\n\n## tremoloskew\n\n## tremolophase\n\n## tremoloshape\n\n# Amplitude Envelope\n\nAmplitude [envelope](<https://en.wikipedia.org/wiki/Envelope_(music)>) контролирует динамический контур звука.\nStrudel использует ADSR envelopes, которые, вероятно, являются наиболее распространенным способом описания envelope:\n\n![ADSR](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/ADSR_parameter.svg/1920px-ADSR_parameter.svg.png)\n\n[ссылка на изображение](https://commons.wikimedia.org/wiki/File:ADSR_parameter.svg)\n\n## attack\n\n## decay\n\n## sustain\n\n## release\n\n## adsr\n\n# Filter Envelope\n\nКаждый filter может получить дополнительный filter envelope, динамически контролирующий значение cutoff. Он использует ADSR envelope, аналогичный используемому для амплитуды. Есть дополнительный параметр для контроля глубины модуляции filter: `lpenv`|`hpenv`|`bpenv`. Это позволяет вам воспроизводить тонкие или огромные модуляции filter просто увеличивая или уменьшая глубину.\n\nЕсть один filter envelope для каждого типа filter и, следовательно, один набор параметров envelope filter с префиксом `lp`, `hp` или `bp`:\n\n- `lpattack`, `lpdecay`, `lpsustain`, `lprelease`, `lpenv`: filter envelope для lowpass filter.\n  - альтернативно: `lpa`, `lpd`, `lps`, `lpr` и `lpe`.\n- `hpattack`, `hpdecay`, `hpsustain`, `hprelease`, `hpenv`: filter envelope для highpass filter.\n  - альтернативно: `hpa`, `hpd`, `hps`, `hpr` и `hpe`.\n- `bpattack`, `bpdecay`, `bpsustain`, `bprelease`, `bpenv`: filter envelope для bandpass filter.\n  - альтернативно: `bpa`, `bpd`, `bps`, `bpr` и `bpe`.\n\n## lpattack\n\n## lpdecay\n\n## lpsustain\n\n## lprelease\n\n## lpenv\n\n# Pitch Envelope\n\nВы также можете контролировать высоту тона с помощью envelopes!\nPitch envelopes могут вдохнуть жизнь в статичные звуки:\n\nВы также можете создать прекрасные звуки в стиле chiptune:\n\nДавайте разберем все элементы управления pitch envelope:\n\n## pattack\n\n## pdecay\n\n## prelease\n\n## penv\n\n## pcurve\n\n## panchor\n\n# Dynamics\n\n## gain\n\n## velocity\n\n## compressor\n\n## postgain\n\n## xfade\n\n# Panning\n\n## jux\n\n## juxBy\n\n## pan\n\n# Waveshaping\n\n## coarse\n\n## crush\n\n## distort\n\n# Global Effects\n\n## Local vs Global Effects\n\nВ то время как вышеперечисленные \"локальные\" effects всегда будут создавать отдельную цепочку effects для каждого event,\nglobal effects используют одну и ту же цепочку для всех events одного orbit:\n\n## orbit\n\n## Delay\n\n### delay\n\n### delaytime\n\n### delayfeedback\n\n## Reverb\n\n### room\n\n### roomsize\n\n### roomfade\n\n### roomlp\n\n### roomdim\n\n### iresponse\n\n## Phaser\n\n### phaser\n\n### phaserdepth\n\n### phasercenter\n\n### phasersweep\n\n## Duck\n\n### ",
    "category": "learn",
    "keywords": [
      "audio",
      "effects",
      "lpf",
      "distort",
      "synth",
      "sample",
      "pattern",
      "signal",
      "chain",
      "strudel",
      "flow",
      "event",
      "adsr",
      "oscillator",
      "detune",
      "penv",
      "lowpass",
      "phase",
      "vocoder",
      "stretch"
    ],
    "path": "learn/effects.mdx"
  },
  {
    "id": "learn-factories",
    "title": "Создание Patterns",
    "content": "# Создание Patterns\n\nСледующие функции возвращают pattern.\nЭто эквиваленты, используемые Mini Notation:\n\n| function                       | mini             |\n| ------------------------------ | ---------------- |\n| `cat(x, y)`                    | `\"<x y>\"`        |\n| `seq(x, y)`                    | `\"x y\"`          |\n| `stack(x, y)`                  | `\"x,y\"`          |\n| `stepcat([3,x],[2,y])`         | `\"x@3 y@2\"`      |\n| `polymeter([a, b, c], [x, y])` | `\"{a b c, x y}\"` |\n| `polymeterSteps(2, x, y, z)`   | `\"{x y z}%2\"`    |\n| `silence`                      | `\"~\"`            |\n\n## cat\n\n## seq\n\n## stack\n\n## stepcat\n\n## arrange\n\n## polymeter\n\n## polymeterSteps\n\n## silence\n\n## run\n\n## binary\n\n## binaryN\n\nПосле конструкторов Patterns давайте посмотрим, какие [Модификаторы времени](/learn/time-modifiers) доступны.",
    "category": "learn",
    "keywords": [
      "создание",
      "patterns",
      "cat",
      "seq",
      "stack",
      "stepcat",
      "polymeter",
      "polymetersteps",
      "pattern",
      "mini",
      "notation",
      "function",
      "silence",
      "arrange",
      "binary",
      "binaryn",
      "learn",
      "time",
      "modifiers"
    ],
    "path": "learn/factories.mdx"
  },
  {
    "id": "learn-getting-started",
    "title": "Начало работы",
    "content": "# Добро пожаловать\n\nДобро пожаловать на страницы документации Strudel!\n\nЭти страницы познакомят вас со [Strudel](https://strudel.cc/) - веб-окружением для [live coding](https://github.com/toplap/awesome-livecoding/), которое реализует алгоритмический язык pattern [Tidal Cycles](https://tidalcycles.org).\n\n# Что такое Strudel?\n\n[Strudel](https://strudel.cc/) - это версия [Tidal Cycles](https://tidalcycles.org), написанная на [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript), созданная [Alex McLean](https://slab.org) и [Felix Roos](https://froos.cc/) в 2022 году.\nTidal Cycles, также известный как Tidal, это язык для [алгоритмических pattern](https://algorithmicpattern.org), и хотя чаще всего он используется для [создания музыки](https://tidalcycles.org/docs/showcase), его можно использовать для любого вида деятельности по созданию паттернов, включая [ткачество](https://www.youtube.com/watch?v=TfEmEsusXjU).\n\nTidal был впервые реализован как библиотека, написанная на функциональном языке программирования [Haskell](https://www.haskell.org/), и сам по себе он не производит никакого звука.\nДля воспроизведения звука его необходимо подключить к звуковому движку, и по умолчанию это плагин [SuperCollider](https://supercollider.github.io/) под названием [SuperDirt](https://github.com/musikinformatik/SuperDirt/).\nПоэтому начинающим пользователям может быть сложно установить как Tidal Cycles, так и SuperDirt, поскольку есть много мелких деталей, которые нужно учесть.\nОднако Strudel работает непосредственно в вашем веб-браузере, не требует установки какого-либо дополнительного программного обеспечения и может воспроизводить звук самостоятельно.\n\n# Strudel REPL и MiniREPL\n\nОсновное место для создания музыки с помощью Strudel - это [Strudel REPL](https://strudel.cc/) ([что такое REPL?](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop)), но на этих страницах вы также встретите интерактивные \"MiniREPL\", где вы можете слушать и редактировать Strudel patterns.\nПопробуйте нажать на значок воспроизведения ниже:\n\nЗатем отредактируйте текст так, чтобы он читался как `s(\"bd sd cp hh\")` и нажмите значок обновления.\nПоздравляем, вы только что создали свой первый Strudel pattern с помощью live coding!\n\nС помощью Strudel вы можете выразительно писать динамические музыкальные произведения.\nВам не нужно знать JavaScript или Tidal Cycles, чтобы создавать музыку с помощью Strudel.\nЭто интерактивное руководство проведет вас через основы Strudel.\n\n# Покажите мне демо!\n\nЧтобы увидеть и услышать, что может делать Strudel, посетите [Strudel REPL](https://strudel.cc/) и нажмите на значок Shuffle в верхнем меню.\nВы можете почувствовать Strudel, просматривая и редактируя эти примеры и нажимая на значок обновления для применения изменений.\n\nВы также можете просмотреть примеры [здесь](/examples).\n\nКроме того, вы можете попробовать, что может делать Strudel, нажав play на этом треке:\n\n# Strudel - это незавершенная работа 🚧\n\nОбратите внимание, что этот проект все еще находится в экспериментальном состоянии.\nВ будущем некоторые его части могут значительно измениться.\nЭто руководство также далеко от завершения.\nВы можете внести свой вклад, нажав \"Edit this page\" в правом верхнем углу, или посетив [Strudel GitHub page](https://codeberg.org/uzu/strudel/).\n\n# Что дальше?\n\nПереходите на страницу [Notes](/learn/notes).\n\n<br />",
    "category": "learn",
    "keywords": [
      "начало",
      "работы",
      "strudel",
      "https",
      "live",
      "coding",
      "github",
      "toplap",
      "awesome",
      "livecoding",
      "pattern",
      "tidal",
      "cycles",
      "tidalcycles",
      "javascript",
      "developer",
      "mozilla",
      "docs",
      "alex",
      "mclean"
    ],
    "path": "learn/getting-started.mdx"
  },
  {
    "id": "learn-hydra",
    "title": "Hydra",
    "content": "# Использование Hydra внутри Strudel\n\nВы можете писать код [hydra](https://hydra.ojack.xyz/) в strudel! Все, что вам нужно сделать, это вызвать `await initHydra()` в начале:\n\n## H patterns\n\nСуществует специальная функция `H`, которая позволяет использовать pattern как вход для hydra:\n\n## detectAudio\n\nЧтобы использовать захват аудио в hydra, вызовите `initHydra` с параметром конфигурации `{detectAudio:true}`:\n\nВозможно, вы не сможете правильно увидеть это здесь: [открыть в REPL](/#YXdhaXQgaW5pdEh5ZHJhKCkKbGV0IHBhdHRlcm4gPSAiMyA0IDUgWzYgN10qMiIKc2hhcGUoSChwYXR0ZXJuKSkub3V0KG8wKQpuKHBhdHRlcm4pLnNjYWxlKCJBOm1pbm9yIikucGlhbm8oKS5yb29tKDEpIA%3D%3D)\n\nПодобно `detectAudio`, все [доступные опции hydra](https://github.com/hydra-synth/hydra-synth#api) могут быть переданы в `initHydra`.\n\n## feedStrudel\n\nИспользуя опцию `feedStrudel`, вы можете трансформировать визуализации strudel с помощью hydra:",
    "category": "learn",
    "keywords": [
      "hydra",
      "inithydra",
      "strudel",
      "https",
      "ojack",
      "await",
      "patterns",
      "pattern",
      "detectaudio",
      "true",
      "repl",
      "github",
      "synth",
      "feedstrudel"
    ],
    "path": "learn/hydra.mdx"
  },
  {
    "id": "learn-input-devices",
    "title": "Устройства ввода",
    "content": "# Устройства ввода\n\nStrudel поддерживает различные устройства ввода, такие как геймпады и MIDI контроллеры, для манипулирования patterns в реальном времени.",
    "category": "learn",
    "keywords": [
      "устройства",
      "ввода",
      "strudel",
      "midi",
      "patterns"
    ],
    "path": "learn/input-devices.mdx"
  },
  {
    "id": "learn-input-output",
    "title": "MIDI, OSC и MQTT",
    "content": "# MIDI, OSC и MQTT\n\nОбычно Strudel используется для создания patterns звука, используя свой собственный синтезатор на основе '[web audio](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)', называемый [SuperDough](https://codeberg.org/uzu/strudel/src/branch/main/packages/superdough).\n\nТакже возможно создавать patterns других вещей с помощью Strudel, таких как программные и аппаратные синтезаторы с MIDI, другое программное обеспечение с использованием Open Sound Control/OSC (включая синтезатор [SuperDirt](https://github.com/musikinformatik/SuperDirt/), обычно используемый с родственным Strudel проектом [TidalCycles](https://tidalcycles.org/)), или протокол MQTT для 'интернета вещей'.\n\n# MIDI\n\nStrudel поддерживает MIDI без какого-либо дополнительного программного обеспечения (благодаря [webmidi](https://npmjs.com/package/webmidi)), просто добавляя методы к вашему pattern:\n\n## midiin(inputName?)\n\n## midi(outputName?,options?)\n\nЛибо подключите midi устройство, либо используйте IAC Driver (Mac) или Midi Through Port (Linux) для внутренних midi сообщений.\nЕсли outputName не указан, используется первый найденный midi выход.\n\nВ консоли вы увидите лог доступных MIDI устройств, как только запустите код,\nнапример\n\n```\n `Midi connected! Using \"Midi Through Port-0\".`\n```\n\nФункция `.midi()` принимает объект опций со следующими свойствами:\n\n<details>\n<summary>Доступные опции</summary>\n\n| Опция       | Тип          | По умолчанию   | Описание                                                            |\n| ------------ | ------------- | --------- | ---------------------------------------------------------------------- |\n| isController | boolean       | false     | Когда true, отключает отправку note сообщений. Полезно для MIDI контроллеров |\n| latencyMs    | number        | 34        | Задержка в миллисекундах для выравнивания MIDI с аудио движком                |\n| noteOffsetMs | number        | 10        | Смещение в миллисекундах для note-off сообщений для предотвращения глитчей      |\n| midichannel  | number        | 1         | MIDI канал по умолчанию (1-16)                                            |\n| velocity     | number        | 0.9       | Velocity ноты по умолчанию (0-1)                                            |\n| gain         | number        | 1         | Множитель gain по умолчанию для velocity (0-1)                             |\n| midimap      | string        | 'default' | Имя MIDI mapping для использования control changes                        |\n| midiport     | string/number | -         | Имя MIDI устройства или индекс                                              |\n\n</details>\n\n### midiport(outputName)\n\nВыбирает MIDI устройство вывода для использования, pattern может использоваться для переключения между устройствами.\n\n```javascript\n$: midiport('IAC Driver');\n$: note('c a f e').midiport('<0 1 2 3>').midi();\n```\n\n## midichan(number)\n\nВыбирает MIDI канал для использования. Если не используется, `.midi` будет использовать канал 1 по умолчанию.\n\n## midicmd(command)\n\n`midicmd` отправляет MIDI system real-time сообщения для управления таймингом и транспортом на MIDI устройствах.\n\nПоддерживает следующие команды:\n\n- `clock`/`midiClock` - Отправляет MIDI тактовые сообщения\n- `start` - Отправляет MIDI start сообщение\n- `stop` - Отправляет MIDI stop сообщение\n- `continue` - Отправляет MIDI continue сообщение\n\n// Вы можете управлять тактами с помощью pattern и убедиться, что он запускается синхронно при запуске repl.\n// Примечание: Это может вести себя неожиданно, если MIDI изначально не настроен.\n\n## control, ccn && ccv\n\n- `control` отправляет MIDI control change сообщения на ваше MIDI устройство.\n- `ccn` устанавливает cc номер. Зависит от midi mapping вашего синтезатора\n- `ccv` устанавливает cc значение. нормализовано от 0 до 1.\n\nВ приведенном выше фрагменте `ccn` установлен в 74, что является фильтром cutoff для многих синтезаторов. `ccv` управляется saw pattern.\nИмея все в одном pattern, pattern `ccv` будет выровнен с note pattern, потому что структура идет слева по умолчанию.\nНо вы также можете управлять cc сообщениями отдельно следующим образом:\n\nВместо прямой установки `ccn` и `ccv`, вы также можете создавать mappings с помощью `midimaps`:\n\n## midimaps\n\n## defaultmidimap\n\n## progNum (Program Change)\n\n`progNum` отправляет MIDI program change сообщения для переключения между различными пресетами/патчами на вашем MIDI устройстве.\nЗначения program change должны быть числами от 0 до 127.\n\nСообщения program change полезны для переключения между различными звуками инструментов или пресетами во время выступления.\nТочный звук, на который отображается каждый номер программы, зависит от конфигурации вашего MIDI устройства.\n\n## sysex, sysexid && sysexdata (System Exclusive Message)\n\n`sysex` отправляет MIDI System Exclusive (SysEx) сообщения на ваше MIDI устройство.\nSysEx сообщения - это специфичные для устройства команды, которые позволяют более глубокое управление параметрами синтезатора.\nЗначение должно быть массивом чисел от 0-255, представляющих SysEx байты данных.\n\nТочный формат SysEx сообщений зависит от спецификации вашего MIDI устройства.\nОбратитесь к руководству по реализации MIDI вашего устройства для получения подробной информации о поддерживаемых SysEx сообщениях.\n\n## midibend && miditouch\n\n`midibend` устанавливает MIDI pitch bend (-1 - 1)\n`miditouch` устанавливает MIDI key after touch (0-1)\n\n# OSC/SuperDirt/StrudelDirt\n\nВ TidalCycles звук обычно генерируется с использованием [SuperDirt](https://github.com/musikinformatik/SuperDirt/), который работает внутри SuperCollider. Strudel также поддерживает использование SuperDirt, хотя это требует установки дополнительного программного обеспечения.\n\nТакже существует [StrudelDirt](https://github.com/daslyfe/StrudelDirt), который является SuperDirt с некоторыми оптимизациями для работы со Strudel. (Долгосрочная цель - объединить эти оптимизации обратно в основной SuperDirt)\n\n## Предварительные требования\n\nЧтобы заставить SuperDirt работать со Strudel, вам нужно\n\n1. установить SuperCollider + sc3 плагины, см. [Tidal Docs](https://tidalcycles.org/docs/) (Install Tidal) для получения дополнительной информации.\n2. установить SuperDirt, или форк [StrudelDirt](https://github.com/daslyfe/StrudelDirt), который оптимизирован для использования со Strudel\n3. установить [node.js](https://nodejs.org/en/)\n4. скачать [Strudel Repo](https://codeberg.org/uzu/strudel/) (или git clone, если у вас установлен git)\n5. запустить `pnpm i` в директории strudel\n6. запустить `pnpm run osc` для запуска osc сервера, который пересылает OSC сообщения из Strudel REPL в SuperCollider\n\nТеперь вы готовы!\n\n## Использование\n\n1. Запустите SuperCollider, используя SuperCollider IDE или запустив `sclang` в терминале\n2. Откройте [Strudel REPL](https://strudel.cc/#cygiYmQgc2QiKS5vc2MoKQ%3D%3D)\n\n...или протестируйте это здесь:\n\nЕсли вы теперь слышите звук, поздравляем! Если нет, вы можете получить помощь в [#strudel канале в TidalCycles discord](https://discord.com/invite/HGEdXmRkzT).\n\nПримечание: если у вас в настройках 'Audio Engine Target' установлен в 'OSC', вам не нужно добавлять .osc() в конец вашего pattern.\n\n### Pattern.osc\n\n## SuperDirt параметры\n\nПожалуйста, обратитесь к [Tidal Docs](https://tidalcycles.org/) для получения дополнительной информации.\n\n<br />\n\nНо можем ли мы использовать Strudel [в оффлайн](/learn/pwa)?\n\n# MQTT\n\nMQTT - это легковесный сетевой протокол, разработанный для устройств 'интернета вещей'. Для использования со strudel вам понадобится доступ к MQTT серверу, известному как 'broker', настроенному для приема безопасных 'websocket' соединений. Вы можете запустить его самостоятельно (например, запустив [mosquitto](https://mosquitto.org/)), хотя получение SSL сертификата, которому будет доверять ваш веб-браузер, может быть немного сложным для тех, кто не имеет опыта системного администрирования.\nВ качестве альтернативы вы можете использовать [публичный broker](https://www.hivemq.com/mqtt/public-mqtt-broker/).\n",
    "category": "learn",
    "keywords": [
      "midi,",
      "osc",
      "mqtt",
      "midiin",
      "midi",
      "midiport",
      "note",
      "midichan",
      "midicmd",
      "strudel",
      "patterns",
      "audio",
      "https",
      "developer",
      "mozilla",
      "docs",
      "superdough",
      "codeberg",
      "branch",
      "main"
    ],
    "path": "learn/input-output.mdx"
  },
  {
    "id": "learn-metadata",
    "title": "Метаданные музыки",
    "content": "# Метаданные музыки\n\nВы можете опционально добавить некоторые метаданные музыки в свой код Strudel, используя теги в комментариях:\n\n```js\n// @title Hey Hoo\n// @by Sam Tagada\n// @license CC BY-NC-SA\n```\n\nКак и другие комментарии, они игнорируются Strudel, но могут использоваться другими инструментами для получения информации о музыке.\n\n## Альтернативный синтаксис\n\nВы также можете использовать блоки комментариев:\n\n```js\n/*\n@title Hey Hoo\n@by Sam Tagada\n@license CC BY-NC-SA\n*/\n```\n\nИли определить несколько тегов в одной строке:\n\n```js\n// @title Hey Hoo @by Sam Tagada @license CC BY-NC-SA\n```\n\nТег `title` имеет альтернативный синтаксис с использованием кавычек (должен быть определен в самом начале):\n\n```js\n// \"Hey Hoo\" @by Sam Tagada\n```\n\n## Список тегов\n\nДоступные теги:\n\n- `@title`: название музыки\n- `@by`: автор(ы) музыки, разделенные запятой, опционально с ссылкой в `<>` (например: `@by John Doe <https://example.com>`)\n- `@license`: лицензия(и) музыки, например CC BY-NC-SA. Не уверены? [Выберите creative commons лицензию здесь](https://creativecommons.org/choose/)\n- `@details`: дополнительная информация о музыке\n- `@url`: веб-страница(ы), связанные с музыкой (git репозиторий, ссылка soundcloud и т.д.)\n- `@genre`: жанр(ы) музыки (pop, jazz и т.д.)\n- `@album`: название музыкального альбома\n\n## Несколько значений\n\nНекоторые из них принимают несколько значений, используя разделитель запятой или новой строки, или дублируя тег:\n\n```js\n/*\n@by Sam Tagada\n    Jimmy\n@genre pop, jazz\n@url https://example.com\n@url https://example.org\n*/\n```\n\nВы также можете добавлять опциональные префиксы и использовать теги где угодно:\n\n```js\n/*\nsong @by Sam Tagada\nsamples @by Jimmy\n*/\n...\nnote(\"a3 c#4 e4 a4\") // @by Sandy\n```\n\n## Многострочные\n\nЕсли тег не принимает список, он может принимать многострочные значения:\n\n```js\n/*\n@details Я написал эту песню 19 февраля 2023 года.\n         Было около полуночи, и я лежал на\n         диване в гостиной.\n*/\n```",
    "category": "learn",
    "keywords": [
      "метаданные",
      "музыки",
      "note",
      "strudel",
      "title",
      "tagada",
      "license",
      "john",
      "https",
      "example",
      "creative",
      "commons",
      "creativecommons",
      "choose",
      "details",
      "soundcloud",
      "genre",
      "jazz",
      "album",
      "jimmy"
    ],
    "path": "learn/metadata.mdx"
  },
  {
    "id": "learn-mini-notation",
    "title": "Mini Notation",
    "content": "# Mini-notation\n\nТак же как и [Tidal Cycles](https://tidalcycles.org/), Strudel использует так называемый \"Mini-Notation\", который представляет собой специальный язык, предназначенный для записи ритмических patterns с использованием небольшого количества текста.\n\n## Примечание\n\nЭта страница объясняет весь синтаксис Mini-Notation целиком.\nЕсли вы только начинаете работать со Strudel, вы можете изучить основы Mini-Notation более практичным способом в [workshop](/workshop/first-sounds).\nПосле этого вы можете вернуться сюда, если хотите понять каждую мелочь.\n\n## Пример\n\nПрежде чем углубляться в детали, вот как выглядит Mini-Notation:\n\n## Формат Mini Notation\n\nПриведенный выше фрагмент заключен в обратные кавычки (`), что позволяет писать многострочные строки.\n\nВы также можете использовать обычные двойные кавычки (`\"`) для однострочного mini-notation, как мы уже делали.\n\nЕсли вы хотите получить обычную строку, которая _не_ парсится как mini-notation, используйте одинарные кавычки (`'`).\n\n## Последовательности events в cycle\n\nМы можем воспроизвести больше нот, разделив их пробелами:\n\nЗдесь эти четыре ноты сжаты в один cycle, поэтому каждая нота длится четверть секунды.\nПопробуйте добавить или удалить ноты и обратите внимание, как меняется темп!\n\nОбратите внимание, что общая продолжительность времени не меняется, вместо этого уменьшается длительность каждой ноты.\nЭто ключевая идея, так как она иллюстрирует 'Cycle' в TidalCycles!\n\nКаждая нота, разделенная пробелом в этой последовательности, является _event_.\nПродолжительность времени каждого event зависит от скорости или темпа cycle и от того, сколько events присутствует.\nВозьмем два приведенных выше примера: у нас четыре и восемь events соответственно, и поскольку у них одинаковая длительность cycle, каждому нужно вместить свои events в одно и то же количество времени.\n\nЭто, возможно, противоречит интуиции, если вы привыкли добавлять ноты в секвенсор или piano roll, и общая длина увеличивается.\nНо это начнет иметь смысл, когда мы рассмотрим больше элементов mini-notation.\n\n## Умножение\n\nПоследовательность можно ускорить, умножив ее на число с помощью символа звездочки (`*`):\n\nУмножение на два здесь означает, что последовательность будет воспроизводиться дважды за cycle.\n\nУмножения также могут быть десятичными (`*2.75`):\n\n## Деление\n\nВ противоположность умножению, деление может замедлить последовательность, заключив ее в скобки и разделив на число (`/2`):\n\nДеление на два означает, что последовательность будет воспроизводиться в течение двух cycles.\nВы также можете использовать десятичные числа для любого темпа, который вам нравится (`/2.75`).\n\n## Угловые скобки\n\nИспользуя угловые скобки `<>`, мы можем определить длину последовательности на основе количества events:\n\nПриведенный выше фрагмент аналогичен:\n\nПреимущество угловых скобок в том, что мы можем добавлять больше events без необходимости изменять число в конце.\n\nЭто более похоже на традиционные музыкальные секвенсоры и piano rolls, где добавление ноты увеличивает воспринимаемую общую продолжительность.\nМы также можем воспроизводить определенное количество нот за cycle, используя угловые скобки с умножением:\n\nТеперь мы воспроизводим 8 нот за cycle!\n\n## Подразделение времени с вложенными скобками\n\nЧтобы создать более интересные ритмы, вы можете _вложить_ или _заключить_ последовательности (поместить последовательности внутрь последовательностей) с помощью скобок `[]`, вот так:\n\nСравните разницу между следующими:\n\nЧто здесь происходит? Когда мы вкладываем/заключаем несколько events внутри скобок (`[]`), их длительность становится равной длине одного event во внешней последовательности.\n\nЭто очень простое изменение, но оно имеет глубокие последствия.\nПомните, что мы говорили ранее о том, как cycles в tidal остаются одинаковой длины, а длительности отдельных events делятся в этом cycle?\nЧто ж, это означает, что в TidalCycles вы не только можете делить время любым способом, но и можете подразделять время любым способом!\n\n## Паузы\n\nСимвол \"~\" представляет паузу и создаст тишину между другими events:\n\n## Параллельность / полифония\n\nИспользуя запятые, мы можем воспроизводить аккорды.\nСледующие примеры одинаковы:\n\nНо чтобы воспроизвести несколько аккордов в последовательности, нужно обернуть их в скобки:\n\n## Удлинение\n\nС помощью символа \"@\" мы можем указать временной \"вес\" дочернего элемента последовательности:\n\nЗдесь первый аккорд имеет вес 2, что делает его в два раза длиннее других аккордов. Вес по умолчанию — 1.\n\n## Повторение\n\nИспользуя \"!\" мы можем повторять без ускорения:\n\n## Случайность\n\nEvents с \"?\" после них будут иметь 50% шанс быть удаленными из pattern:\n\nДобавление числа между 0 и 1 после \"?\" повлияет на вероятность удаления event. Например, events с \"?0.1\" после них будут иметь 10% шанс быть удаленными:\n\nEvents, разделенные \"|\", будут выбраны случайным образом:\n\n## Обзор mini-notation\n\nЧтобы подытожить то, что мы узнали до сих пор, сравните следующие patterns:\n\n## Euclidian rhythms\n\nИспользуя круглые скобки после event, мы можем создавать ритмические подразделения на основе трех параметров: `beats`, `segments` и `offset`.\nЭтот алгоритм можно найти во многих различных типах музыкального программного обеспечения, и он часто называется секвенсором [Euclidean rhythm](https://en.wikipedia.org/wiki/Euclidean_rhythm), в честь компьютерного ученого Годфрида Туссена.\nПочему это интересно? Рассмотрим следующий простой пример:\n\nЗвучит знакомо?\nЭто популярный Euclidian rhythm, известный под различными названиями, такими как \"Pop Clave\".\nЭти ритмы можно найти во всех музыкальных культурах, и алгоритм Euclidian rhythm позволяет нам выразить их чрезвычайно легко.\nНаписание этого ритма полностью требует описания:\n\nНо используя нотацию Euclidian rhythm, нам нужно выразить только \"3 удара на 8 сегментов, начиная с позиции 1\".\n\nЭто упрощает написание patterns с интересными ритмическими структурами и вариациями, которые все еще звучат знакомо:\n\nОбратите внимание, что поскольку в приведенном выше примере не используется третий параметр `offset`, его можно записать просто как `\"(3,8)\"`.\n\nДавайте подробно рассмотрим эти три параметра.\n\n### Beats\n\n`beats`: первый параметр контролирует, сколько ударов будет воспроизведено.\nСравните эти:\n\n### Segments\n\n`segments`: второй параметр контролирует общее количество сегментов, по которым будут распределены удары:\n\n### Offsets\n\n`offset`: третий (необязательный) параметр контролирует начальную позицию для распределения ударов.\nНам нужен вторичный ритм, чтобы услышать разницу:\n\n## Упражнение по mini-notation\n\nСамое интересное в mini-notation — это то, что все, что вы только что изучили, можно комбинировать различными способами!\n\nНачиная с этого одного `n`, можете ли вы создать _строку pattern_, которая использует каждый отдельный элемент mini-notation, упомянутый выше?\n\n<br />\n\nДалее: Как [Samples](/learn/samples) вписываются в это?",
    "category": "learn",
    "keywords": [
      "mini",
      "notation",
      "tidal",
      "cycles",
      "https",
      "tidalcycles",
      "strudel",
      "patterns",
      "workshop",
      "first",
      "sounds",
      "events",
      "cycle",
      "event",
      "piano",
      "roll",
      "rolls",
      "pattern",
      "euclidian",
      "rhythms"
    ],
    "path": "learn/mini-notation.mdx"
  },
  {
    "id": "learn-mondo-notation",
    "title": "Mondo Notation",
    "content": "# Mondo Notation\n\n\"Mondo Notation\" - это новый вид нотации, похожий на [Mini Notation](/learn/mini-notation/), но с достаточными возможностями, чтобы работать как самостоятельный язык patterns.\nВот пример:\n\n## Mondo в REPL\n\nПока что вы можете использовать mondo в repl только так:\n\nОстальная часть этого сайта будет использовать только саму mondo нотацию.\nВ будущем REPL может получить способ использовать mondo нотацию напрямую.\n\n## Вызов функций\n\nПо сравнению с Mini Notation, наиболее заметной особенностью Mondo Notation является возможность вызывать функции с помощью круглых скобок:\n\nПервый элемент внутри скобок - это имя функции. В JS это выглядело бы так:\n\nВнешние скобки не нужны, поэтому мы можем их опустить:\n\n## Возможности Mini Notation\n\nПомимо вызова функций с круглыми скобками, Mondo Notation имеет много общего с Mini Notation:\n\n### Скобки\n\n- `[]` для 1-cycle последовательностей\n- `<>` для multi-cycle последовательностей\n- `{}` для ступенчатых последовательностей (подробнее об этом позже)\n\n### Инфиксные операторы\n\n- \\* => [fast](/learn/time-modifiers/#fast)\n- / => [slow](/learn/time-modifiers/#slow)\n- ! => [extend](/learn/stepwise/#extend)\n- @ => [expand](/learn/stepwise/#expand)\n- % => [pace](/learn/stepwise/#pace)\n- ? => [degradeBy](/learn/random-modifiers/#degradeby) (в настоящее время требует правого операнда)\n- : => tail (создает список)\n- .. => range (между числами)\n- , => [stack](/learn/factories/#stack)\n- | => [chooseIn](/learn/random-modifiers/#choose)\n\n### Пример\n\n## Цепочка функций\n\nПодобно тому, как работает \".\" в javascript (JS), мы можем связывать вызовы функций с оператором \"#\":\n\nВот то же самое, написанное на JS:\n\n### Локальная цепочка функций\n\nФункцию можно применить к одному элементу, обернув его в круглые скобки:\n\nв этом случае `delay .6` будет применен только к `cp`. сравните это с версией JS:\n\nздесь мы видим, сколько мы можем сэкономить, когда нет границы между mini notation и вызовами функций!\n\n### Цепочка инфиксных операторов\n\nИнфиксные операторы существуют как обычные функции, поэтому их также можно связывать:\n\nВ этом случае \\*2 будет применен ко всему pattern.\n\n### Lambda функции\n\nНекоторые функции в strudel ожидают функцию в качестве входных данных, например:\n\nв mondo `x=>x.` можно сократить до:\n\nцепочка работает как ожидается:\n\n## Строки\n\nВы можете использовать \"двойные кавычки\" и 'одинарные кавычки', чтобы получить строку:\n\n## Несколько Patterns\n\nЗнак `$` может использоваться для разделения нескольких patterns:\n\nЗнак `$` является псевдонимом для `,`, поэтому он создаст stack за кулисами.\n\n## переменные\n\nиспользуя ключевое слово `def`, вы можете определять переменные:",
    "category": "learn",
    "keywords": [
      "mondo",
      "notation",
      "mini",
      "learn",
      "patterns",
      "repl",
      "cycle",
      "multi",
      "fast",
      "time",
      "modifiers",
      "slow",
      "extend",
      "stepwise",
      "expand",
      "pace",
      "degradeby",
      "random",
      "tail",
      "range"
    ],
    "path": "learn/mondo-notation.mdx"
  },
  {
    "id": "learn-notes",
    "title": "Notes",
    "content": "# Notes\n\nВысота тона — важный строительный блок во многих музыкальных традициях.\nВ Strudel высота тона может быть выражена в виде имен нот, номеров нот или частот.\nВот один и тот же pattern, записанный тремя разными способами:\n\n- `note`: буквенная нотация, подходит для тех, кто знаком с западной теорией музыки:\n\n  \n\n- `note`: числовая нотация, подходит для тех, кто хочет использовать узнаваемые высоты, но не заботится о теории музыки:\n\n  \n\n- `freq`: нотация частоты, подходит для тех, кто хочет выйти за рамки стандартизированных систем настройки:\n\n  \n\nДавайте рассмотрим их более подробно...\n\n## Имена `note`\n\nИмена нот могут быть записаны с буквой ноты, за которой следует номер октавы. Вы можете обозначить бемоли с помощью `b`, а диезы с помощью `#`.\n\nКстати, вы можете редактировать содержимое плеера и нажимать \"update\", чтобы услышать ваше изменение!\nВы также можете нажать \"play\" на следующем плеере без необходимости останавливать последний.\n\n## Числа `note`\n\nЕсли хотите, вы также можете использовать числа с `note`:\n\nЭти числа интерпретируются как так называемые [MIDI numbers](https://www.inspiredacoustics.com/en/MIDI_note_numbers_and_center_frequencies), где соседние целые числа отстоят друг от друга на один 'semitone'.\n\nВы также можете писать десятичные числа, чтобы получить 'microtonal' высоты (между черными и белыми клавишами piano):\n\n## `freq`\n\nЧтобы получить максимальную свободу, вы также можете использовать `freq` для прямого управления частотой:\n\n## Слух и частота\n\nВ приведенном выше примере мы воспроизводим A3 (220Hz), C#4 natural (275Hz), E4 (330Hz) и A4 (440Hz), отражая наши предыдущие примеры.\n\nНо можете ли вы услышать разницу между этими отдельными частотами?\n\nА эти?\n\nЧем выше мы поднимаемся...\n\nТем меньше расстояния мы можем услышать между частотами!\n\nПочему это так? [Человеческий слух работает логарифмически](https://www.audiocheck.net/soundtests_nonlinear.php).\n\n## От нот к звукам\n\nНа этой странице, когда мы воспроизводили pattern нот вот так:\n\nМы слышали простой синтезированный звук, на самом деле мы слышали [triangle wave oscillator](https://en.wikipedia.org/wiki/Triangle_wave).\n\nЭто синтезатор по умолчанию, используемый Strudel, но как же тогда создавать разные звуки в Strudel?\n\nДавайте узнаем об этом на следующей странице [Sounds](/learn/sounds).\n\n<br />",
    "category": "learn",
    "keywords": [
      "notes",
      "strudel",
      "pattern",
      "note",
      "freq",
      "update",
      "play",
      "midi",
      "numbers",
      "https",
      "semitone",
      "microtonal",
      "piano",
      "natural",
      "audiocheck",
      "triangle",
      "wave",
      "oscillator",
      "wikipedia",
      "wiki"
    ],
    "path": "learn/notes.mdx"
  },
  {
    "id": "learn-pwa",
    "title": "Оффлайн",
    "content": "# Использование Strudel в оффлайн режиме\n\nВы можете использовать Strudel даже без сетевого подключения! Когда вы впервые посещаете [Strudel REPL](https://strudel.cc/),\nваш браузер загрузит все веб-приложение, включая документацию.\nКогда загрузка завершена (&lt;1MB), вы можете посещать веб-сайт даже в оффлайн режиме,\nполучая загруженный веб-сайт вместо онлайн версии.\n\nКогда сайт обновляется, ваш браузер загрузит это обновление при следующем онлайн посещении.\nКогда обновление доступно, сайт обновится после завершения загрузки.\n\nЭто работает, потому что Strudel реализован как progessive web app (используя [Vite PWA](https://vite-pwa-org.netlify.app/)).\n\n## Samples\n\nХотя браузер загрузит само приложение, samples загружаются только когда вы их активно используете.\nПоэтому, чтобы убедиться, что конкретный набор samples доступен в оффлайн режиме, просто используйте их.\nТакже, только samples с этих доменов будут кешироваться для оффлайн использования:\n\n- `https://raw.githubusercontent.com/*` для samples, загруженных на github\n- `https://freesound.org/*` / `https://cdn.freesound.org/*` для freesound\n- `https://shabda.ndre.gr/.*` для shabda\n\n## Проверка / Очистка кеша\n\nВы можете просмотреть все кешированные файлы в вашем браузере.\n\n### Firefox\n\n- Откройте Developer Tools (`Tools > Web Developer > Web Developer Tools`)\n- перейдите на вкладку `Storage` и разверните `Cache Storage > https://strudel.cc`.\n- или перейдите на вкладку `Application` и просмотрите последние обновления в `Service Workers`\n\n### Браузеры на основе Chromium\n\n- Откройте Developer Tools (`Правый клик > Inspect`)\n- перейдите на вкладку `Application`\n- просмотрите загруженные файлы в `Cache > Cache Storage`\n- просмотрите последние обновления в `Service Workers`\n\n## Автономное приложение Strudel\n\nВы также можете установить Strudel как автономное приложение на большинстве устройств.\nАвтономное приложение имеет свою собственную иконку на рабочем столе / главном экране и запускается в отдельном окне,\nбез интерфейса браузера.\n\n<figure>\n  ![Strudel on MacOS](/pwa/strudel-macos.png)\n  <figcaption>Strudel на MacOS</figcaption>\n</figure>\n\n### Рабочий стол\n\nС браузером на основе chromium:\n\n1. перейдите в [Strudel REPL](https://strudel.cc).\n2. справа от адресной строки нажмите `install Strudel REPL`\n3. REPL теперь должен запускаться как автономное chromium приложение\n\nБез браузера на основе chromium вы можете использовать [nativefier](https://github.com/nativefier/nativefier) для генерации приложения для рабочего стола:\n\n1. убедитесь, что у вас установлен NodeJS\n2. запустите `npx nativefier strudel.cc`\n\n<figure>\n  ![Strudel on Linux](/pwa/strudel-linux.png)\n  <figcaption>Strudel на Linux</figcaption>\n</figure>\n\n### iOS\n\n1. откройте [Strudel REPL](https://strudel.cc/) в safari\n2. нажмите иконку поделиться и выберите `Add to homescreen`\n3. Теперь у вас должна быть иконка приложения strudel, которая открывает repl в полноэкранном режиме\n\n### Android\n\n1. откройте [Strudel REPL](https://strudel.cc/)\n2. Нажмите кнопку установки внизу\n\nИтак, что такое [Patterns](/technical-manual/patterns)?",
    "category": "learn",
    "keywords": [
      "оффлайн",
      "strudel",
      "repl",
      "https",
      "progessive",
      "vite",
      "netlify",
      "samples",
      "github",
      "freesound",
      "shabda",
      "ndre",
      "firefox",
      "developer",
      "tools",
      "storage",
      "cache",
      "application",
      "service",
      "workers"
    ],
    "path": "learn/pwa.mdx"
  },
  {
    "id": "learn-random-modifiers",
    "title": "Случайные модификаторы",
    "content": "# Случайные модификаторы\n\nЭти методы добавляют случайное поведение к вашим Patterns.\n\n## choose\n\n## wchoose\n\n## chooseCycles\n\n## wchooseCycles\n\n## degradeBy\n\n## degrade\n\n## undegradeBy\n\n## undegrade\n\n## sometimesBy\n\n## sometimes\n\n## someCyclesBy\n\n## someCycles\n\n## often\n\n## rarely\n\n## almostNever\n\n## almostAlways\n\n## never\n\n## always\n\nДалее: [Условные модификаторы](/learn/conditional-modifiers)",
    "category": "learn",
    "keywords": [
      "случайные",
      "модификаторы",
      "patterns",
      "choose",
      "wchoose",
      "choosecycles",
      "wchoosecycles",
      "degradeby",
      "degrade",
      "undegradeby",
      "undegrade",
      "sometimesby",
      "sometimes",
      "somecyclesby",
      "somecycles",
      "often",
      "rarely",
      "almostnever",
      "almostalways",
      "never"
    ],
    "path": "learn/random-modifiers.mdx"
  },
  {
    "id": "learn-samples",
    "title": "Samples",
    "content": "# Samples\n\nSamples — это наиболее распространенный способ создания звука в tidal и strudel.\nSample — это (обычно короткий) фрагмент аудио, который используется в качестве основы для генерации звука и подвергается различным преобразованиям.\nМузыку, основанную на samples, можно представить как коллаж из звуков. [Подробнее о Sampling](<https://en.wikipedia.org/wiki/Sampling_(music)>)\n\nStrudel позволяет загружать samples в виде аудиофайлов различных форматов (wav, mp3, ogg) из любого общедоступного URL.\n\n# Default Samples\n\nПо умолчанию strudel поставляется со встроенной \"sample map\", обеспечивающей надежную основу для экспериментов.\n\nЗдесь мы используем функцию `s` для воспроизведения различных стандартных samples (`bd`, `sd`, `hh` и `misc`), чтобы получить барабанный бит.\n\nДля барабанных звуков strudel использует обширную библиотеку [tidal-drum-machines](https://github.com/ritchse/tidal-drum-machines) со следующими обозначениями:\n\n| Drum                 | Abbreviation |\n| -------------------- | ------------ |\n| Bass drum, Kick drum | bd           |\n| Snare drum           | sd           |\n| Rimshot              | rim          |\n| Clap                 | cp           |\n| Closed hi-hat        | hh           |\n| Open hi-hat          | oh           |\n| Crash                | cr           |\n| Ride                 | rd           |\n| High tom             | ht           |\n| Medium tom           | mt           |\n| Low tom              | lt           |\n\n<img src=\"/img/drumset.png\" />\n\n<a class=\"text-right text-xs\" href=\"https://de.wikipedia.org/wiki/Schlagzeug#/media/Datei:Drum_set.svg\" target=\"_blank\">\n  original von Pbroks13\n</a>\n\nДополнительные перкуссионные звуки:\n\n| Source                              | Abbreviation |\n| ----------------------------------- | ------------ |\n| Shakers (and maracas, cabasas, etc) | sh           |\n| Cowbell                             | cb           |\n| Tambourine                          | tb           |\n| Other percussions                   | perc         |\n| Miscellaneous samples               | misc         |\n| Effects                             | fx           |\n\nКроме того, strudel также загружает samples инструментов из [VCSL](https://github.com/sgossner/VCSL) по умолчанию.\n\nЧтобы увидеть, какие имена samples доступны, откройте вкладку `sounds` в [REPL](https://strudel.cc/).\n\nВы также можете создавать пользовательские псевдонимы для существующих звуков, используя функцию `soundAlias`:\n\nОбратите внимание, что изначально загружаются только sample maps (отображение имен на URL), а сами аудио samples не загружаются до тех пор, пока они не будут воспроизведены.\nТакое поведение загрузки вещей только тогда, когда они нужны, также называется `lazy loading`.\nХотя это экономит ресурсы, это также может привести к тому, что звуки не будут слышны при первом воспроизведении, потому что звук все еще загружается.\n[Это может быть исправлено в будущем](https://codeberg.org/uzu/strudel/issues/187)\n\n# Sound Banks\n\nЕсли мы откроем вкладку `sounds`, а затем `drum-machines`, мы увидим, что все drum samples имеют префиксы с названиями драм-машин: `RolandTR808_bd`, `RolandTR808_sd`, `RolandTR808_hh` и т.д.\n\nМы _могли бы_ использовать их так:\n\n... но это, очевидно, слишком много для написания. Используя функцию `bank`, мы можем сократить это до:\n\nВы даже можете паттернизировать bank для переключения между различными драм-машинами:\n\nЗа кулисами `bank` просто добавляет имя драм-машины к имени sample с `_` для получения полного имени.\nЭто, конечно, работает только потому, что имя после `_` (`bd`, `sd` и т.д.) стандартизировано.\nТакже обратите внимание, что у некоторых banks может не быть samples для всех звуков!\n\n# Selecting Sounds\n\nЕсли мы снова откроем вкладку `sounds`, затем вкладку `drum machines`, там также есть число за каждым именем, указывающее, сколько отдельных samples доступно.\nНапример, `RolandTR909_hh(4)` означает, что доступно 4 samples хэта TR909.\nПо умолчанию `s` будет воспроизводить первый sample, но мы можем выбрать другие, используя `n`, начиная с 0:\n\nСлишком большие числа просто обернутся к началу\n\nЗдесь 0-3 будут воспроизводить те же звуки, что и 4-7, потому что `RolandTR909_hh` имеет только 4 звука.\n\nВыбор звуков также работает внутри mini notation, используя \"`:`\" вот так:\n\n# Loading Custom Samples\n\nВы можете загрузить нестандартную sample map, используя функцию `samples`.\n\n## Loading samples from file URLs\n\nВ этом примере мы назначаем имена `bassdrum`, `hihat` и `snaredrum` конкретным аудиофайлам на сервере:\n\nВы можете свободно выбирать любую комбинацию букв для каждого имени sample. Даже можно переопределить стандартные звуки.\nВыбранные вами имена будут доступны в функции `s`.\nУбедитесь, что URL и каждый путь к sample образуют правильный URL!\n\nВ приведенном выше примере `bassdrum` загрузит:\n\n```\nhttps://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/bd/BT0AADA.wav\n|----------------------base path --------------------------------|--sample path-|\n```\n\nОбратите внимание, что мы можем загрузить либо один файл, как для `bassdrum` и `hihat`, либо список файлов, как для `snaredrum`!\nКак только вы запустите код, выбранные вами имена samples будут перечислены в `sounds` -> `user`.\n\n## Loading Samples from a strudel.json file\n\nПриведенный выше способ загрузки samples может быть утомительным для записи / копирования-вставки каждый раз, когда вы пишете новый pattern.\nЧтобы избежать этого, вы можете просто передать URL к файлу `strudel.json` где-то в интернете:\n\nОжидается, что файл определит sample map с использованием JSON в том же формате, что описан выше.\nКроме того, базовый путь может быть определен с помощью ключа `_base`.\nПоследний раздел можно записать как:\n\n```json\n{\n  \"_base\": \"https://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/\",\n  \"bassdrum\": \"bd/BT0AADA.wav\",\n  \"snaredrum\": \"sd/rytm-01-classic.wav\",\n  \"hihat\": \"hh27/000_hh27closedhh.wav\"\n}\n```\n\nОбратите внимание, что браузеры часто кэшируют `strudel.json` при первой загрузке и продолжают использовать кэшированную\nверсию, даже если оригинал был обновлен. Если это вас беспокоит (например, при разработке нового\nsample pack), вы можете заставить браузер загрузить новую копию, например, изменив регистр одного\nсимвола в URL или добавив атрибут URL, например:\n\n```javascript\nsamples('https://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/strudel.json?version=2');\n```\n\nкоторый игнорируется GitHub (но изменяет URL, заставляя браузер перезагружать при каждом увеличении\nномера версии).\n\nТакже возможно, конечно, просто удалить его из кэша (удаление кэша в настройках конфиденциальности браузера,\nили из консоли разработчика, если вы технически подкованы, или с помощью расширения для удаления кэша).\n\n## Generating strudel.json\n\nВы можете использовать [@strudel/sampler](https://www.npmjs.com/package/@strudel/sampler) для генерации файла strudel.json, выполнив:\n\n```sh\nnpx --yes @strudel/sampler --json > strudel.json\n```\n\nСмотрите другие способы использования strudel/sampler ниже, в разделе \"From Disk via @strudel/sampler\".\n\n## Github Shortcut\n\nПоскольку загрузка samples из github является распространенной, есть сокращение:\n\nФормат: `samples('github:<user>/<repo>/<branch>')`. Если вы опустите `branch` (как выше), будет использована ветка `main`.\nПредполагается наличие файла `strudel.json` в корне репозитория:\n\n```\nhttps://raw.githubusercontent.com/<user>/<repo>/<branch>/strudel.json\n```\n\n## From Disk via \"Import Sounds Folder\"\n\nЕсли вы не хотите загружать свои samples в интернет, вы также можете загрузить их с локального диска.\nПерейдите на вкладку `sounds` в REPL и откройте вкладку `import-sounds` под строкой поиска.\nНажмите кнопку \"import sounds folder\" и выберите папку, содержащую аудиофайлы.\nВыбранная вами папка также может содержать подпапки с аудиофайлами.\nПример:\n\n```\n└─ samples\n   ├─ swoop\n   │  ├─ swoopshort.wav\n   │  ├─ swooplong.wav\n   │  └─ swooptight.wav\n   └─ smash\n      ├─ smashhigh.wav\n      ├─ smashlow.wav\n      └─ smashmiddle.wav\n```\n\nВ приве",
    "category": "learn",
    "keywords": [
      "samples",
      "swoop",
      "smash",
      "tidal",
      "strudel",
      "sample",
      "sampling",
      "https",
      "wikipedia",
      "wiki",
      "music",
      "default",
      "misc",
      "drum",
      "machines",
      "github",
      "ritchse",
      "abbreviation",
      "bass",
      "kick"
    ],
    "path": "learn/samples.mdx"
  },
  {
    "id": "learn-signals",
    "title": "Сигналы",
    "content": "# Непрерывные сигналы\n\nСигналы - это patterns с непрерывными значениями, что означает, что они имеют теоретически бесконечное количество шагов.\nОни могут предоставлять потоки чисел, которые можно сэмплировать в дискретные моменты времени.\n\n## saw\n\n## sine\n\n## cosine\n\n## tri\n\n## square\n\n## rand\n\n## Диапазоны от -1 до 1\n\nТакже существуют `saw2`, `sine2`, `cosine2`, `tri2`, `square2` и `rand2`, которые имеют диапазон от -1 до 1!\n\n## perlin\n\n## irand\n\n## brand\n\n## brandBy\n\n## mouseX\n\n## mouseY\n\nДалее: [Random Modifiers](/learn/random-modifiers)",
    "category": "learn",
    "keywords": [
      "сигналы",
      "patterns",
      "sine",
      "cosine",
      "square",
      "rand",
      "perlin",
      "irand",
      "brand",
      "brandby",
      "mousex",
      "mousey",
      "random",
      "modifiers",
      "learn"
    ],
    "path": "learn/signals.mdx"
  },
  {
    "id": "learn-sounds",
    "title": "Sounds",
    "content": "# Sounds\n\nМы можем воспроизводить звуки с помощью `s` двумя разными способами:\n\n- `s` может запускать audio samples, где звуковой файл загружается в фоновом режиме и воспроизводится:\n  \n- `s` может запускать audio synthesisers, которые синтезируются в реальном времени с помощью кода, также работающего в фоновом режиме:\n  \n\nВы можете узнать больше об обоих этих подходах на страницах [Synths](/learn/synths) и [Samples](/learn/samples).\n\n# Комбинирование нот и звуков\n\nВ обоих вышеприведенных случаях мы больше не контролируем напрямую `note`/`freq` звука, слышимого через `s`, как это было на странице [Notes](/workshop/first-notes/).\n\nТак как же мы можем контролировать и звук, и высоту тона? Мы можем _комбинировать_ `note`/`freq` с `s`, чтобы изменить звук наших высот:\n\nПоследний пример на самом деле будет звучать одинаково с `s` или без него, потому что `triangle` — это значение по умолчанию для `s`.\n\nЧто насчет комбинирования разных нот с разными звуками одновременно?\n\nХм, здесь происходит что-то интересное, связанное с тем, что есть пять нот и три звука.\n\nТеперь давайте сделаем шаг назад и подумаем о [Code](/learn/code/) Strudel, который мы слышали до сих пор.",
    "category": "learn",
    "keywords": [
      "sounds",
      "audio",
      "samples",
      "synthesisers",
      "synths",
      "learn",
      "note",
      "freq",
      "notes",
      "workshop",
      "first",
      "triangle",
      "code",
      "strudel"
    ],
    "path": "learn/sounds.mdx"
  },
  {
    "id": "learn-stepwise",
    "title": "Stepwise patterning",
    "content": "# Stepwise patterning (экспериментально)\n\nЭто развивающаяся область strudel, и поведение может измениться или быть переименовано в будущих версиях. Отзывы и идеи приветствуются!\n\n## Введение\n\nОбычно в strudel единственной точкой отсчета для большинства преобразований patterns является _cycle_. Теперь также возможно работать с _шагами_ (steps) через растущий набор функций.\n\nНапример, обычно когда вы используете `fastcat` для объединения двух patterns, cycles будут сжаты в половину cycle каждый:\n\nС новой stepwise функцией `stepcat`, шаги двух patterns будут равномерно распределены по cycle:\n\nПо умолчанию шаги подсчитываются в соответствии с 'верхним уровнем' в mini-notation. Например, `\"a [b c] d e\"` имеет пять событий в cycle, но считается как четыре шага, где `[b c]` считается как один шаг.\n\nОднако вы можете отметить другой метрический уровень для подсчета шагов, используя `^` в начале sub-pattern. Если мы сделаем это с subpattern в нашем примере: `\"a [^b c] d e\"`, то pattern теперь будет считаться имеющим _восемь_ шагов. Это потому, что 'b' и 'c' каждый считаются как отдельные шаги, а события в pattern в два раза длиннее, и поэтому считаются как два шага каждое.\n\n## Управление темпом шагов\n\nНекоторые stepwise функции сами по себе не кажутся делающими много, например, эти два примера функции `expand` звучат абсолютно одинаково, несмотря на разные значения расширения:\n\nКоличество шагов на cycle изменяется за кулисами, но само по себе это ничего не делает. Однако вы услышите разницу, когда используете другую stepwise функцию вместе с ней, например `stepcat`:\n\nВы должны услышать, что `expand` увеличивает длительность шагов первого subpattern пропорционально второму.\n\nВы также можете изменить скорость pattern в соответствии с заданным количеством шагов на cycle с помощью функции `pace`:\n\nПервый пример имеет десять шагов, а второй пример - 18 шагов, но затем оба воспроизводятся со скоростью 8 шагов на cycle.\n\nАргумент `expand` также может быть pattern, и будет обрабатываться в stepwise манере. Это означает, что patterns из изменяющихся значений в аргументе будут объединены с помощью `stepcat`:\n\nЭто приводит к плотному pattern, потому что разные расширенные версии сжаты в один cycle. `pace` снова удобен здесь для замедления pattern до определенного количества шагов на cycle:\n\nРанние версии многих из этих функций имели префикс `s_`, а функция `pace` ранее была известна как `steps`. Они все еще существуют как псевдонимы, но поведение могло измениться, и скоро они будут удалены. Пожалуйста, обновите ваши patterns!\n\n## Stepwise функции\n\n### pace\n\n### stepcat\n\n### stepalt\n\n### expand\n\n### contract\n\n### extend\n\n### take\n\n### drop\n\n### polymeter\n\n### shrink\n\n### grow\n\n### tour\n\n### zip",
    "category": "learn",
    "keywords": [
      "stepwise",
      "patterning",
      "strudel",
      "patterns",
      "steps",
      "fastcat",
      "cycles",
      "cycle",
      "stepcat",
      "mini",
      "notation",
      "pattern",
      "subpattern",
      "expand",
      "pace",
      "stepalt",
      "contract",
      "extend",
      "take",
      "drop"
    ],
    "path": "learn/stepwise.mdx"
  },
  {
    "id": "learn-strudel-vs-tidal",
    "title": "Strudel vs Tidal",
    "content": "# Сравнение Strudel и Tidal\n\nЭта страница посвящена существующим пользователям tidal, предоставляя обзор всех различий между Strudel и Tidal.\n\n## Язык\n\nStrudel написан на JavaScript, в то время как Tidal написан на Haskell.\n\n### Пример\n\nЭто различие наиболее очевидно при взгляде на синтаксис:\n\n```haskell\niter 4 $ every 3 (||+ n \"10 20\") $ (n \"0 1 3\") # s \"triangle\" # crush 4\n```\n\nМожно было бы выразить этот pattern в Strudel так:\n\n```\niter(4, every(3, add.squeeze(\"10 20\"), n(\"0 1 3\").s(\"triangle\").crush(4)))\n```\n\n- Оператор `$` не существует, поэтому функция `iter` должна обернуть все в скобки.\n- Пользовательские операторы типа `||+` являются явными вызовами функций, в данном случае `add.squeeze`\n- Оператор `#` заменен цепочкой вызовов функций `# crush 4` => `.crush(4)`\n\nВ отличие от Haskell, JavaScript не имеет возможности определять пользовательские инфиксные операторы или изменять значение существующих.\n\nПрежде чем вы отвергнете Strudel как громоздкое чудовище из скобок, посмотрите на этот альтернативный способ написать вышеприведенное:\n\n```\nn(\"0 1 3\").every(3, add.squeeze(\"10 20\")).iter(4).s(\"triangle\").crush(4)\n```\n\nПереупорядочив вызовы, скобки гораздо менее вложены.\nВ качестве общего правила можно сказать, что все, что Tidal делает с `$`, меняется местами в Strudel:\n\n`iter 4 $ every 3 (||+ n \"10 20\") $ (n \"0 1 3\")`\n\nстановится\n\n`n(\"0 1 3\").every(3, add.squeeze(\"10 20\")).iter(4)`\n\nПроще говоря, `foo x $ bar x` становится `bar(x).foo(x)`.\n\n### Операторы\n\n[Пользовательские операторы tidal](https://tidalcycles.org/docs/reference/pattern_structure/#all-the-operators) являются обычными функциями в strudel:\n\n| функция  | tidal  | strudel |\n| -------- | ------ | ------- |\n| add      | \\|+ n  | .add(n) |\n| subtract | \\|- n  | .sub(n) |\n| multiply | \\|\\* n | .mul(n) |\n| divide   | \\|\\/ n | .div(n) |\n| modulo   | \\|\\% n | .mod(n) |\n| left values | \\|\\< n | .set(n) |\n\nПриведенный выше список отображает только операторы, где структура берется из `left`.\nДля каждого из них также существует вариант `right` и `both`.\nПоскольку это направленное мышление работает только с кодом, strudel называет их `in` / `out` / `mix`:\n\n| направление | tidal   | strudel     |\n| ----------- | ------- | ----------- |\n| left        | \\|+ n   | .add.in(n)  |\n| right       | +\\| n   | .add.out(n) |\n| both        | \\|+\\| n | .add.mix(n) |\n\nВместо `+` / `add`, вы можете использовать любой из доступных операторов из первого списка.\n\n## Совместимость функций\n\n[Этот issue](https://codeberg.org/uzu/strudel/issues/31) отслеживает, какие функции Tidal реализованы в Strudel.\nСписок может быть не на 100% актуальным и, вероятно, также упускает некоторые функции полностью..\nНе стесняйтесь искать функцию, которую вы ищете, в исходном коде.\nЕсли вы найдете функцию, которой нет в списке, пожалуйста, сообщите!\n\n## Параметры управления\n\nКак видно из примера, оператор `#` (сокращение для `|>`) также является просто вызовом функции в strudel.\nИтак, `note \"c5\" # s \"gtr\"` становится `note(\"c5\").s('gtr')`.\n\n[Этот файл](https://codeberg.org/uzu/strudel/src/branch/main/packages/core/controls.mjs) перечисляет все доступные параметры управления.\nОбратите внимание, что не все из них работают в Webaudio Output в Strudel.\nЕсли вы найдете параметр управления tidal, которого нет в списке, пожалуйста, сообщите!\n\n## Звук\n\nTidal обычно используется вместе с Superdirt / Supercollider для генерации звука.\nХотя Strudel также имеет способ [взаимодействия с Superdirt](/learn/input-output/),\nон стремится предоставить автономную среду live coding, которая полностью работает в браузере.\n\n### Аудиоэффекты\n\nМногие эффекты SuperDirt были переработаны в Strudel с использованием Web Audio API.\nВы можете найти [список доступных эффектов здесь](/learn/effects/).\n\n### Сэмплер\n\nСэмплер Strudel поддерживает [подмножество](/learn/samples) сэмплера Superdirt.\nКроме того, samples всегда загружаются из URL, а не с диска, хотя [это может быть возможно в будущем](https://codeberg.org/uzu/strudel/issues/118).\n\n## Выполнение\n\nREPL Strudel еще не поддерживает [блочное выполнение](https://codeberg.org/uzu/strudel/issues/34).\nВы можете использовать именованные операторы и `_` для отключения:\n\n## Темп\n\nТемп Strudel - 1 cycle в секунду, в то время как tidal по умолчанию использует `0.5625`.\nВы можете получить тот же темп, что и в tidal, с помощью:\n\n```\nnote(\"c a f e\").fast(.5625);\n```\n\nДалее: [REPL](/technical-manual/repl)",
    "category": "learn",
    "keywords": [
      "strudel",
      "tidal",
      "iter",
      "every",
      "squeeze",
      "crush",
      "bar",
      "foo",
      "add",
      "sub",
      "mul",
      "div",
      "mod",
      "set",
      "in",
      "out",
      "mix",
      "note",
      "fast",
      "javascript"
    ],
    "path": "learn/strudel-vs-tidal.mdx"
  },
  {
    "id": "learn-synths",
    "title": "Synths",
    "content": "# Synths\n\nВ дополнение к движку сэмплирования, strudel поставляется с синтезатором для создания звуков на лету.\n\n## Базовые Waveforms\n\nБазовые waveforms — это `sine`, `sawtooth`, `square` и `triangle`, которые можно выбрать через `sound` (или `s`):\n\nЕсли вы не установите `sound`, но установите `note`, значением по умолчанию для `sound` будет `triangle`!\n\n## Noise\n\nВы также можете использовать noise в качестве источника, установив waveform на: `white`, `pink` или `brown`. Это разные\nвиды noise, здесь написаны от жесткого к мягкому.\n\nВот более музыкальный пример использования noise для хэтов:\n\nНекоторое количество pink noise также может быть добавлено к любому oscillator с помощью параметра `noise`:\n\nВы также можете использовать тип `crackle` для воспроизведения тонких шумовых треска. Вы можете контролировать количество noise, используя параметр `density`:\n\n### Additive Synthesis\n\nПериодические waveforms состоят из нескольких [harmonics](https://en.wikipedia.org/wiki/Harmonic) выше основной частоты, расположенных на целых кратных. Эти обертоны объединяются, чтобы придать звуку его уникальное тембральное качество.\n\nДля базовых waveforms мы предлагаем вам контроль над этими harmonics с помощью функций `partials` и `phases`.\n\n#### Partials\n\n`partials` относится к величине каждого harmonic относительно основной частоты. Таким образом, их можно использовать для спектральной фильтрации этих waveforms и смягчения некоторой их резкости:\n\n`partials` также можно использовать для построения _новых_ waveforms, отсутствующих в нашем базовом наборе, с помощью источника звука 'user':\n\nМы можем алгоритмически создавать списки величин с помощью кода Javascript следующим образом:\n\nчто действует как спектральный filter. Или:\n\nчто восстанавливает знакомую waveform.\n\n`partials` также совместим с функциями pattern, предназначенными для создания списков, такими как `randL` или `binaryL`:\n\nи со списками _из_ patterns:\n\nОбратите внимание, что первое значение в массиве `partials` контролирует величину фундаментального harmonic, а не смещение по постоянному току, которое зафиксировано на 0.\n\n#### Phases\n\nРанее мы упоминали, что периодические waveforms можно разложить на набор harmonics выше основной частоты. Каждый harmonic имеет два определяющих свойства: его величину (насколько он громкий) и его фазу, которая определяет, где в своем цикле начинается эта синусоида при построении waveform.\n\nЭти phases также могут быть объявлены в Strudel и могут придать вашим звукам интересную глубину.\n\n## Vibrato\n\n### vib\n\n### vibmod\n\n## FM Synthesis\n\nFM Synthesis — это техника, которая быстро изменяет частоту базовой waveform для изменения тембра.\n\nВы можете использовать fm с любой из вышеперечисленных waveforms, хотя все приведенные ниже примеры используют triangle wave по умолчанию.\n\n### fm\n\n### fmh\n\n### fmattack\n\n### fmdecay\n\n### fmsustain\n\n### fmenv\n\n## Wavetable Synthesis\n\nStrudel также может использовать sampler для загрузки пользовательских waveforms в качестве замены waveforms по умолчанию, используемых WebAudio для базового synth. Набор по умолчанию из более чем 1000 wavetables доступен по умолчанию (из набора [AKWF](https://www.adventurekid.se/akrt/waveforms/adventure-kid-waveforms/)). Вы также можете импортировать/использовать свои собственные. Wavetable — это waveform одного цикла, которая затем повторяется для создания звука на желаемой частоте. Это классическая, но очень эффективная техника синтеза.\n\nЛюбой sample с префиксом `wt_` будет загружен как wavetable. Это означает, что аргумент `loop` будет установлен на `1` по умолчанию. Вы также можете сканировать wavetable, используя `loopBegin` и `loopEnd`.\n\n## ZZFX\n\n\"Zuper Zmall Zound Zynth\" [ZZFX](https://github.com/KilledByAPixel/ZzFX) также интегрирован в strudel.\nРазработанный [Frank Force](https://frankforce.com/), это движок synth и FX, изначально предназначенный для использования в играх с ограниченным размером кода.\n\nУ него всего 20 параметров, вот фрагмент, который использует все:\n\nОбратите внимание, что вы также можете комбинировать zzfx со всеми другими audio fx (следующая глава).\n\nДалее: [Audio Effects](/learn/effects)...",
    "category": "learn",
    "keywords": [
      "synths",
      "strudel",
      "waveforms",
      "sine",
      "sawtooth",
      "square",
      "triangle",
      "sound",
      "note",
      "noise",
      "waveform",
      "white",
      "pink",
      "brown",
      "oscillator",
      "crackle",
      "density",
      "additive",
      "synthesis",
      "harmonics"
    ],
    "path": "learn/synths.mdx"
  },
  {
    "id": "learn-themes",
    "title": "Темы редактора",
    "content": "# Темы редактора\n\nBulka поддерживает 40 встроенных цветовых тем для редактора кода. Вы можете переключать темы прямо из музыкального кода или через настройки.\n\n## Переключение темы из кода\n\nИспользуйте функцию `theme()` для динамического переключения темы:\n\n### Автоматическое переключение тем\n\nМожно переключать темы по очереди в такт музыке:\n\n### Все 40 тем в одном паттерне\n\n## Список всех тем\n\n### Тёмные темы (30)\n\n| Тема | Описание |\n|------|----------|\n| `strudelTheme` | Стандартная тёмная тема (по умолчанию) |\n| `algoboy` | Ретро-стиль Game Boy |\n| `archBtw` | Arch Linux стиль |\n| `androidstudio` | Android Studio |\n| `atomone` | Atom One Dark |\n| `aura` | Фиолетовая Aura |\n| `bbedit` | BBEdit |\n| `blackscreen` | Чёрный экран |\n| `bluescreen` | Синий экран (BSOD стиль) |\n| `CutiePi` | Милая розовая тема |\n| `darcula` | JetBrains Darcula |\n| `dracula` | Популярная Dracula |\n| `duotoneDark` | Двухтоновая тёмная |\n| `eclipse` | Eclipse Dark |\n| `fruitDaw` | Fruit DAW стиль |\n| `githubDark` | GitHub Dark |\n| `greenText` | Зелёный текст на чёрном |\n| `gruvboxDark` | Gruvbox Dark |\n| `sonicPink` | Sonic Pink |\n| `materialDark` | Material Dark |\n| `monokai` | Классическая Monokai |\n| `noctisLilac` | Noctis Lilac |\n| `nord` | Nord (скандинавский стиль) |\n| `redText` | Красный текст на чёрном |\n| `solarizedDark` | Solarized Dark |\n| `sublime` | Sublime Text |\n| `teletext` | Телетекст ретро |\n| `tokyoNight` | Tokyo Night |\n| `tokyoNightStorm` | Tokyo Night Storm |\n| `vscodeDark` | VS Code Dark |\n\n### Светлые темы (10)\n\n| Тема | Описание |\n|------|----------|\n| `bluescreenlight` | Светлый синий |\n| `githubLight` | GitHub Light |\n| `gruvboxLight` | Gruvbox Light |\n| `materialLight` | Material Light |\n| `solarizedLight` | Solarized Light |\n| `tokyoNightDay` | Tokyo Night Day |\n| `vscodeLight` | VS Code Light |\n| `whitescreen` | Белый экран |\n| `xcodeLight` | Xcode Light |\n\n## Переключение через настройки\n\n1. Откройте панель настроек (иконка шестерёнки)\n2. Найдите раздел \"Theme\"\n3. Выберите тему из выпадающего списка\n\nВыбранная тема сохраняется в localStorage и восстанавливается при следующем посещении.\n\n## Создание кастомных тем\n\nКаждая тема определяется в отдельном `.mjs` файле в папке `packages/codemirror/themes/`.\n\n### Структура темы\n\n```javascript\n\n// Основные настройки цветов\nexport const settings = {\n  background: '#222',           // Фон редактора\n  lineBackground: '#22222299',  // Фон строки кода\n  foreground: '#fff',           // Цвет текста\n  caret: '#ffcc00',             // Цвет курсора\n  selection: 'rgba(128, 203, 196, 0.5)', // Цвет выделения\n  selectionMatch: '#036dd626',  // Цвет совпадений при поиске\n  lineHighlight: '#00000050',   // Подсветка активной строки\n  gutterBackground: 'transparent', // Фон панели номеров строк\n  gutterForeground: '#8a919966',   // Цвет номеров строк\n  light: false,                 // true для светлых тем\n};\n\n// Создание темы с подсветкой синтаксиса\nexport default createTheme({\n  theme: 'dark', // или 'light'\n  settings,\n  styles: [\n    { tag: t.keyword, color: '#c792ea' },      // Ключевые слова\n    { tag: t.string, color: '#c3e88d' },       // Строки\n    { tag: t.number, color: '#c3e88d' },       // Числа\n    { tag: t.comment, color: '#7d8799' },      // Комментарии\n    { tag: t.variableName, color: '#c792ea' }, // Переменные\n    { tag: t.operator, color: '#89ddff' },     // Операторы\n    { tag: t.bracket, color: '#525154' },      // Скобки\n  ],\n});\n```\n\n### Доступные теги для подсветки синтаксиса\n\n- `t.keyword` — ключевые слова (if, else, function)\n- `t.string` — строки в кавычках\n- `t.number` — числа\n- `t.comment` — комментарии\n- `t.variableName` — имена переменных\n- `t.operator` — операторы (+, -, *, /)\n- `t.bracket` — скобки\n- `t.propertyName` — свойства объектов\n- `t.className` — имена классов\n- `t.tagName` — теги\n- `t.meta` — метаданные\n- `t.atom` — атомарные значения\n- `t.bool` — булевы значения\n\n### Добавление новой темы\n\n1. Создайте файл `packages/codemirror/themes/my-theme.mjs`\n2. Экспортируйте `settings` и тему по умолчанию\n3. Импортируйте тему в `packages/codemirror/themes.mjs`\n4. Добавьте в объекты `themes` и `settings`\n\nПосле этого тема будет доступна через `theme(\"myTheme\")` и в настройках.\n\n## Ссылки\n\n- [Исходный код тем](https://github.com/timoncool/Bulka/tree/main/packages/codemirror/themes)",
    "category": "learn",
    "keywords": [
      "темы",
      "редактора",
      "theme",
      "rgba",
      "createtheme",
      "bulka",
      "strudeltheme",
      "algoboy",
      "game",
      "archbtw",
      "arch",
      "linux",
      "androidstudio",
      "android",
      "studio",
      "atomone",
      "atom",
      "dark",
      "aura",
      "bbedit"
    ],
    "path": "learn/themes.mdx"
  },
  {
    "id": "learn-time-modifiers",
    "title": "Модификаторы времени",
    "content": "# Модификаторы времени\n\nСледующие функции каким-либо образом изменяют временную структуру pattern.\nНекоторые из них имеют эквивалентные операторы в Mini Notation:\n\n| функция                | mini         |\n| ---------------------- | ------------ |\n| `\"x\".slow(2)`          | `\"x/2\"`      |\n| `\"x\".fast(2)`          | `\"x*2\"`      |\n| `\"x\".euclid(3,8)`      | `\"x(3,8)\"`   |\n| `\"x\".euclidRot(3,8,1)` | `\"x(3,8,1)\"` |\n\n## slow\n\n## fast\n\n## early\n\n## late\n\n## clip / legato\n\n## euclid\n\n### euclidRot\n\n### euclidLegato\n\n## rev\n\n## palindrome\n\n## iter\n\n### iterBack\n\n## ply\n\n## segment\n\n## compress\n\n## zoom\n\n## linger\n\n## fastGap\n\n## inside\n\n## outside\n\n## cpm\n\n## ribbon\n\n## swingBy\n\n## swing\n\nПомимо изменения времени, существуют способы [управления параметрами](/functions/value-modifiers/).",
    "category": "learn",
    "keywords": [
      "модификаторы",
      "времени",
      "slow",
      "fast",
      "euclid",
      "euclidrot",
      "pattern",
      "mini",
      "notation",
      "early",
      "late",
      "clip",
      "legato",
      "euclidlegato",
      "palindrome",
      "iter",
      "iterback",
      "segment",
      "compress",
      "zoom"
    ],
    "path": "learn/time-modifiers.mdx"
  },
  {
    "id": "learn-tonal",
    "title": "Тональные функции",
    "content": "# Тональные функции\n\nЭти функции используют [tonaljs](https://github.com/tonaljs/tonal) для предоставления помощников для музыкальных операций.\n\n### voicing()\n\nВот пример того, как можно играть аккорды и басовую линию:\n\n### scale(name)\n\n### transpose(semitones)\n\nТранспонирует все ноты на заданное количество полутонов:\n\nЭтот метод становится действительно интересным, когда мы используем его с pattern, как показано выше.\n\nВместо чисел можно использовать научную нотацию интервалов:\n\n### scaleTranspose(steps)\n\nТранспонирует ноты внутри гаммы на количество шагов:\n\n### rootNotes(octave = 2)\n\nПревращает символы аккордов в основные ноты аккордов в заданной октаве.\n\nВместе с layer, struct и voicings это может быть использовано для создания базового аккомпанемента:",
    "category": "learn",
    "keywords": [
      "тональные",
      "функции",
      "voicing",
      "scale",
      "transpose",
      "scaletranspose",
      "rootnotes",
      "tonaljs",
      "https",
      "github",
      "tonal",
      "name",
      "semitones",
      "pattern",
      "steps",
      "octave",
      "layer",
      "struct",
      "voicings"
    ],
    "path": "learn/tonal.mdx"
  },
  {
    "id": "learn-visual-feedback",
    "title": "Визуальная обратная связь",
    "content": "# Визуальная обратная связь\n\nСуществует несколько функций, которые добавляют визуальную обратную связь к вашим patterns.\n\n## Подсветка Mini Notation\n\nКогда вы пишете mini notation с \"двойными кавычками\" или \\`обратными кавычками\\`, активные части mini notation будут подсвечиваться:\n\nВы также можете изменить цвет, даже создать pattern для него:\n\n## Глобальные против встроенных визуализаций\n\nСледующие функции имеют 2 варианта.\n\n**Без префикса**: рендерит визуализацию на фон страницы:\n\n**С префиксом `_`**: рендерит визуализацию внутри кода. Позволяет использовать несколько визуализаций\n\nЗдесь мы видим 2 варианта для `punchcard`. То же самое работает для всех остальных ниже.\nДля улучшения читаемости следующие демонстрации будут использовать встроенный вариант.\n\n## Punchcard / Pianoroll\n\nЭти 2 функции рендерят визуализацию в стиле pianoroll.\nЕдинственная разница между ними в том, что `pianoroll` будет рендерить pattern напрямую,\nв то время как `punchcard` также будет учитывать трансформации, которые происходят после:\n\nЗдесь `color` все еще виден в визуализации, даже если он применен после `_punchcard`.\nНапротив, цвет не виден при использовании `_pianoroll`:\n\n<br />\n\nВизуализация может быть настроена путем передачи опций. Эти опции одинаковы для обеих функций.\n\nДалее следует API документация всех опций, которые вы можете передать:\n\n## Spiral\n\n## Scope\n\n## Pitchwheel\n\n## Spectrum\n\n## markcss",
    "category": "learn",
    "keywords": [
      "визуальная",
      "обратная",
      "связь",
      "patterns",
      "mini",
      "notation",
      "pattern",
      "punchcard",
      "pianoroll",
      "color",
      "spiral",
      "scope",
      "pitchwheel",
      "spectrum",
      "markcss"
    ],
    "path": "learn/visual-feedback.mdx"
  },
  {
    "id": "learn-xen",
    "title": "Ксеногармонические функции",
    "content": "# Ксеногармонические функции\n\nЭти функции позволяют использовать гаммы, отличные от типичных хроматических 12-тоновых.\n\n### tune(scale)\n\nВот пример настройки базовой гаммы hexany:\n\nПопробуйте другие гаммы, такие как `hexany1`, `iraq`, `gumbeng`, `gunkali`, или `tranh3`\n\nПолный список доступных гамм из tunejs см. на http://abbernie.github.io/tune/scales.html\n\nВы можете установить свою основную ноту на определенную ноту с помощью `getFreq`\n\nНекоторые строи становятся более выраженными с более длительным затуханием reverb:\n\nКроме того, вы можете комбинировать это с `fmap`, чтобы базовая нота изменялась:\n\nКомбинирование этого с различными трюками полиритмии может стать очень выразительным:\n\nЕще одна полезная уловка при изучении новых строев - играть их арпеджио.\nМногие имеют гораздо более очаровательное звучание, которое было выбрано в течение многих поколений музыкантов за игру арпеджио.\n\nВозьмем строй `sanza`:\n\nНоты 7 и 9 будут довольно сильно конфликтовать, если вы играете их арпеджио обычным способом. Многие строи будут иметь такое звучание, и это может отвлекать само по себе.\nПосмотрите, как они близко на pitch wheel?\n\nЭто качество часто связано с тем, как строи формировались с инструментами, на которых играли иначе, чем на фортепиано.\nТаким образом, на некоторых строях гораздо лучше играть арпеджио, где тонкий конфликт расстроенных нот фактически делает звук гораздо более магическим:\n\nОбратите внимание, что эффекты legato и reverb обеспечивают, чтобы звук арпеджио смешивался вместе. Чередование направления арпеджио может сделать\nтона еще более живыми.\n\nСтрой `tranh3` имеет похожий набор нот с двумя конфликтующими. Вы можете попробовать подставить его выше и посмотреть, найдете ли вы любимый паттерн арпеджио.",
    "category": "learn",
    "keywords": [
      "ксеногармонические",
      "функции",
      "tune",
      "scale",
      "hexany",
      "iraq",
      "gumbeng",
      "gunkali",
      "tunejs",
      "http",
      "abbernie",
      "github",
      "scales",
      "html",
      "getfreq",
      "reverb",
      "fmap",
      "sanza",
      "pitch",
      "wheel"
    ],
    "path": "learn/xen.mdx"
  },
  {
    "id": "recipes-arpeggios",
    "title": "Создание Arpeggios",
    "content": "Примечание: Это было (частично) переведено с https://tidalcycles.org/docs/patternlib/howtos/buildarpeggios\n\n# Создание Arpeggios\n\nЭта страница научит вас, как начать писать arpeggios, используя различные техники. Это хороший способ изучить Strudel более интуитивно.\n\n## Arpeggios из нот\n\nНачните с простой последовательности нот:\n\nТеперь давайте проигрывать по одной на cycle:\n\nПоверх этого поместите копию последовательности, сдвинутую по времени и высоте:\n\nДобавьте структуру в исходную последовательность:\n\nРеверсируем в одном динамике:\n\nДавайте добавим ещё один слой:\n\n- добавлен slow(2) для приближения к cps tidal\n- n был заменён на note, потому что использование n не работает как note для samples\n- legato 2 был удалён, потому что не работает в комбинации с rev (баг)\n\n## Arpeggios из аккордов\n\nTODO",
    "category": "recipes",
    "keywords": [
      "создание",
      "arpeggios",
      "slow",
      "https",
      "tidalcycles",
      "docs",
      "patternlib",
      "howtos",
      "buildarpeggios",
      "strudel",
      "cycle",
      "tidal",
      "note",
      "samples",
      "legato",
      "todo"
    ],
    "path": "recipes/arpeggios.mdx"
  },
  {
    "id": "recipes-microrhythms",
    "title": "Microrhythms",
    "content": "смотрите https://strudel.cc/?zMEo5kowGrFc\n\n# Microrhythms\n\nВдохновлённые этой [Мини-лекцией о нотации Microrhythm](https://www.youtube.com/watch?v=or7B6vI3jOo), давайте посмотрим, как мы можем выразить microrhythms с помощью Strudel.\n\nВременные метки первого ритма - `0 1/5 1/2 2/3 1`. Мы могли бы наивно выразить это с помощью stack:\n\nХотя это работает, у этого есть две проблемы:\n\n- это не очень компактно\n- длительности неправильные, например, первая нота занимает весь cycle\n\nВ видео длительность временной метки вычисляется путём вычитания её из следующей временной метки:\n\n- 1/5 - 0 = 1/5 = 6/30\n- 1/2 - 1/5 = 3/10 = 9/30\n- 2/3 - 1/2 = 1/6 = 5/30\n- 1 - 2/3 = 1/3 = 10/30\n\nИспользуя их, мы теперь можем выразить ритм гораздо короче:\n\nПроблемы первой нотации теперь исправлены: она гораздо короче, и длительности правильные.\nТем не менее, эта нотация требовала вычисления длительностей вручную, что можно автоматизировать:\n\nЭта нотация ещё короче, и она позволяет напрямую вводить временные метки!\n\nЭто второй пример из видео:\n\nс басом: https://strudel.cc/?sTglgJJCPIeY",
    "category": "recipes",
    "keywords": [
      "microrhythms",
      "https",
      "strudel",
      "microrhythm",
      "youtube",
      "watch",
      "stack",
      "cycle",
      "stglgjjcpiey"
    ],
    "path": "recipes/microrhythms.mdx"
  },
  {
    "id": "recipes-recipes",
    "title": "Рецепты",
    "content": "# Рецепты\n\nЭта страница показывает возможные способы достижения распространённых (или не очень) музыкальных целей.\nЧасто есть много способов сделать что-то, и нет правильного или неправильного.\nИнтересная часть в том, что каждое представление даёт вам разные импульсы при импровизации.\n\n## Arpeggios\n\nArpeggio - это когда ноты аккорда играются последовательно.\nМы можем либо написать ноты вручную:\n\n...или использовать гаммы:\n\n...или символы аккордов:\n\n...используя off:\n\n## Нарезка брейков\n\nSample можно зациклить и нарезать вот так:\n\nЭто подгоняет брейк под 8 cycles + нарезает его на 16 кусочков.\nНарезка пока не слышна, потому что мы не делаем никаких манипуляций.\nДавайте добавим рандомизированное удвоение + реверсирование:\n\nЕсли мы хотим указать порядок samples, можем заменить `chop` на `slice`:\n\nЕсли использовать `splice` вместо `slice`, скорость подстраивается под длительность события:\n\nОбратите внимание, что нам не нужен `fit`, потому что `splice` сделает это сам.\n\n## Огибающие фильтра\n\nИспользуя `lpenv`, мы можем заставить фильтр двигаться:\n\nТип огибающей зависит от методов, которые вы устанавливаете. Давайте установим `lpa`:\n\nТеперь фильтр атакует, а не затухает как раньше (затухание - это по умолчанию). Мы также можем сделать и то, и другое:\n\nВы можете поэкспериментировать с `lpa` | `lpd` | `lps` | `lpd`, чтобы увидеть, что будет делать огибающая фильтра.\n\n## Наложение звуков\n\nМы можем накладывать звуки, разделяя их запятой \",\":\n\nМы можем контролировать громкость отдельных звуков вот так:\n\nДля большего контроля над каждым голосом можем использовать `layer`:\n\nЗдесь мы придаём sawtooth вибрато, а square перемещаем на октаву вверх.\nС `layer` вы можете использовать любой доступный метод pattern на каждом голосе, так что небо - предел..\n\n## Расстройка осциллятора\n\nМы можем сделать звук толще, добавив к нему расстроенную версию:\n\nПопробуйте разные значения или добавьте ещё один голос!\n\n## Polyrhythms\n\nВот простой пример polyrhythm:\n\nPolyrhythm - это когда два разных темпа происходят одновременно.\n\n## Polymeter\n\nЭто polymeter:\n\nPolymeter - это когда два разных размера такта играют в одном темпе.\n\n## Phasing\n\nЭто phasing:\n\nPhasing происходит, когда одна и та же последовательность играет в слегка разных темпах.\n\n## Пробежка по samples\n\nИспользуя `run` с `n`, мы можем пробежаться по банку samples:\n\nЭто отлично работает с банками samples, содержащими похожие звуки, как в этом случае разные записи табла.\nЧасто вы будете слышать начало фразы не там, где начинается pattern.\nВ этом случае я слышу начало на третьем sample, что можно учесть с помощью `early`.\n\nДавайте добавим немного случайности:\n\n## Дрожание ленты\n\nМы можем эмулировать эффект дрожания высоты звука вот так:\n\n## Длительность звука\n\nЕсть несколько способов изменить длительность звука. Используя clip:\n\nЗначение clip относительно длительности каждого события.\nМы также можем создать перекрытия, используя release:\n\nЭто плавно затухнет каждый звук в течение заданного количества секунд.\nМы также можем сделать ноты короче, используя огибающую затухания:\n\nПри использовании samples у нас также есть `.end` для обрезки относительно длины sample:\n\nСравните это с clip:\n\nили decay:\n\n## Волновой синтез\n\nВы можете зациклить sample с помощью `loop` / `loopEnd`:\n\nЭто позволяет нам проигрывать первые 5% бочки как синтезатор!\nДля упрощения загрузки волновых таблиц любой sample, начинающийся с `wt_`, будет зациклен автоматически:\n\nПробежка по разным волновым таблицам также может дать интересные вариации:\n\n...добавляя огибающую фильтра + reverb:",
    "category": "recipes",
    "keywords": [
      "рецепты",
      "arpeggios",
      "arpeggio",
      "sample",
      "cycles",
      "samples",
      "chop",
      "slice",
      "splice",
      "lpenv",
      "layer",
      "sawtooth",
      "square",
      "pattern",
      "polyrhythms",
      "polyrhythm",
      "polymeter",
      "phasing",
      "early",
      "clip"
    ],
    "path": "recipes/recipes.mdx"
  },
  {
    "id": "recipes-rhythms",
    "title": "Создание ритмов",
    "content": "Примечание:\n\n- это было (частично) переведено с https://tidalcycles.org/docs/patternlib/howtos/buildrhythms\n- это звучит хорошо только с `samples('github:tidalcycles/dirt-samples')` в prebake\n\n# Создание ритмов\n\nЭта страница научит вас, как начать писать ритмы, используя различные техники. Это хороший способ изучить Strudel более интуитивно.\n\n## От простого к сложному ритму\n\nПростая бочка - малый барабан:\n\nДавайте выберем другой sample малого барабана:\n\nТеперь изменим ритм:\n\nИ добавим томы:\n\nНачинаем трансформировать, сдвигаем на четверть cycle через один cycle:\n\nПаттернизируем величину сдвига:\n\nДобавляем эффекты с паттернами:\n\nБольше трансформаций:\n\n## Ещё одна ритмическая конструкция\n\nДавайте начнём с последовательности:\n\nДобавляем немного вкуса:\n\nМеняем samples местами через один cycle:\n\nTODO: реализовать `rot`",
    "category": "recipes",
    "keywords": [
      "создание",
      "ритмов",
      "samples",
      "https",
      "tidalcycles",
      "docs",
      "patternlib",
      "howtos",
      "buildrhythms",
      "github",
      "dirt",
      "prebake",
      "strudel",
      "sample",
      "cycle",
      "todo"
    ],
    "path": "recipes/rhythms.mdx"
  },
  {
    "id": "technical-manual-about",
    "title": "about",
    "content": "Этот раздел знакомит вас со Strudel в техническом смысле. Если вы просто хотите _использовать_ Strudel, обратите внимание на [Руководство](/workshop/getting-started).\n\nTODO",
    "category": "technical-manual",
    "keywords": [
      "about",
      "strudel",
      "workshop",
      "getting",
      "started",
      "todo"
    ],
    "path": "technical-manual/about.mdx"
  },
  {
    "id": "technical-manual-alignment",
    "title": "Выравнивание Pattern",
    "content": "# Выравнивание и комбинирование Pattern\n\nОдним из ключевых аспектов Strudel, унаследованным от Tidal, является гибкий способ комбинирования patterns независимо от их структуры. Его декларативный подход означает, что live coder не нужно думать о деталях того, _как_ это делается, только о том, _что_ должно быть сделано.\n\nВ качестве простого примера рассмотрим два числовых pattern `\"0 [1 2] 3\"` и `\"10 20\"`. Первый имеет три непрерывных шага равной длины, где второй шаг разбит на два подшага, давая четыре события в общей сложности. Существует очень большое количество способов, которыми можно комбинировать структуру этих двух patterns, но метод по умолчанию как в Strudel, так и в Tidal заключается в выравнивании cycles двух patterns, а затем взятии событий из первого pattern и их сопоставлении с событиями второго pattern. Поэтому следующие две строки эквивалентны:\n\n```js\n'0 [1 2] 3'.add('10 20');\n('10 [11 22] 23');\n```\n\nКогда события частично перекрываются, они рассматриваются как фрагменты события из первого pattern. Это немного сложно концептуализировать, но давайте начнем со сравнения двух patterns в следующем примере:\n\n```js\n'0 1 2'.add('10 20');\n('10 [11 21] 22');\n```\n\nОни похожи на предыдущий пример тем, что число `1` разделено на два, и к его двум половинам добавлены `10` и `20` соответственно. Однако `11` 'помнит', что это фрагмент исходного события `1`, и поэтому рассматривается как имеющий длительность в треть cycle, несмотря на то, что активен только в течение шестой части cycle. Аналогично, `21` также является фрагментом исходного события `1`, но фрагментом его второй половины. Поскольку начало его события отсутствует, оно фактически не вызовет звук (если только не подвергнется дальнейшим трансформациям/комбинациям pattern).\n\nНа практике эффект этого неявного метода по умолчанию для комбинирования двух patterns заключается в том, что второй pattern добавляется _в_ первый, и действительно это можно сделать явным:\n\n```js\n'0 1 2'.add.in('10 20');\n```\n\nЭто открывает путь для других способов выравнивания pattern, и несколько уже определены, в частности:\n\n- `in` - как объяснено выше, выравнивает cycles и применяет значения из pattern справа _в_ pattern слева.\n- `out` - как с `in`, но значения применяются _из_ pattern слева (т.е. _в_ тот, что справа).\n- `mix` - структуры из обоих patterns комбинируются, так что новые события не являются фрагментами, а создаются на пересечениях событий с обеих сторон.\n- `squeeze` - cycles из pattern справа сжимаются в события слева. Так что, например, `\"0 1 2\".add.squeeze(\"10 20\")` эквивалентно `\"[10 20] [11 21] [12 22]\"`.\n- `squeezeout` - как с `squeeze`, но cycles слева сжимаются в события справа. Так, `\"0 1 2\".add.squeezeout(\"10 20\")` эквивалентно `[10 11 12] [20 21 22]`.\n- `reset` похож на `squeezeout` в том, что cycles справа выравниваются с событиями слева. Однако эти cycles не 'сжимаются', а усекаются, чтобы соответствовать событию. Так `\"0 1 2 3 4 5 6 7\".add.reset(\"10 [20 30]\")` будет эквивалентно `10 11 12 13 20 21 30 31`. По сути, события справа 'сбрасывают' cycles слева.\n- `restart` похож на `reset`, но pattern 'перезапускается' с самого первого cycle, а не с текущего cycle. `reset` и `restart` поэтому дают разные результаты только там, где самый левый pattern отличается от одного cycle к другому.\n\nМы сохраним более глубокое изучение фона, дизайна и практических аспектов этих функций выравнивания для будущих публикаций. Однако в следующем разделе мы рассмотрим их в качестве кейса для изучения различных возможностей дизайна, предлагаемых Haskell для Tidal и JavaScript для Strudel.\n\nИтак, как же Strudel и Tidal [соотносятся](/learn/strudel-vs-tidal)?",
    "category": "technical-manual",
    "keywords": [
      "выравнивание",
      "pattern",
      "add",
      "in",
      "squeeze",
      "squeezeout",
      "reset",
      "strudel",
      "tidal",
      "patterns",
      "live",
      "coder",
      "cycles",
      "cycle",
      "restart",
      "haskell",
      "javascript",
      "learn"
    ],
    "path": "technical-manual/alignment.mdx"
  },
  {
    "id": "technical-manual-docs",
    "title": "Документация",
    "content": "# Документация\n\nСтраница документации построена на основе [сайта документации astro](https://github.com/withastro/astro/tree/main/examples/docs).\n\n## Добавление новой страницы документации\n\n1. добавьте `.mdx` файл в путь под `website/src/pages/`, например [website/src/pages/learn/code.mdx](https://codeberg.org/uzu/strudel/src/branch/main/website/src/pages/learn/code.mdx) будет доступен по адресу https://strudel.cc/learn/code/ (или локально по адресу `http://localhost:4321/learn/code/`)\n2. убедитесь, что скопировали верхнюю часть другой существующей страницы документации. Настройте заголовок соответственно\n3. Чтобы добавить ссылку на боковую панель, добавьте новую запись в `SIDEBAR` в [`config.ts`](https://codeberg.org/uzu/strudel/src/branch/main/website/src/config.ts)\n\n## Использование Mini REPL\n\nЧтобы добавить Mini REPL, убедитесь, что импортировали:\n\n```js\n\n```\n\nдобавьте mini repl с помощью\n\n```jsx\n\n```\n\n- `client:idle` требуется, чтобы сообщить astro, что repl должен быть интерактивным, см. [Client Directive](https://docs.astro.build/en/reference/directives-reference/#client-directives)\n- `tune`: любой валидный код pattern\n- `punchcard`: если добавлено, отображается визуализация punchcard / pianoroll\n- `drawTime`: временное окно для отрисовки, по умолчанию `[0, 4]`\n- `canvasHeight`: высота canvas, по умолчанию 100px\n\nСм. `mini-notation.mdx` для примеров использования\n\n## Внутренняя документация\n\nВы можете добавить внутреннюю документацию для функции, используя компонент `JsDoc`. Импорт:\n\n```js\n\n```\n\nИспользование:\n\n```jsx\n\n```\n\n- `name`: имя функции, как названо с помощью `@name` в jsdoc\n- `h`: уровень заголовка. `0` скроет заголовок. Скрытие позволяет использовать ручной заголовок, что приводит к генерации навигационной ссылки в правой боковой панели.\n- `hideDescription`: если установлено, описание будет скрыто\n\n### Написание jsdoc\n\nДокументация написана с помощью комментариев [jsdoc](https://jsdoc.app/). Пример:\n\n```js\n/**\n * Select a sound / sample by name.\n *\n * @name s\n * @param {string | Pattern} sound The sound / pattern of sounds to pick\n * @example\n * s(\"bd hh\")\n *\n */\n// implementation of s function\n```\n\n- Перед каждой сборкой эти комментарии будут отрендерены в `doc.json` с использованием [jsdoc-json](https://www.npmjs.com/package/jsdoc-json) в качестве шаблона\n- Чтобы вручную перегенерировать файл `doc.json`, выполните `npm run jsdoc-json`\n- Файл используется компонентом `JsDoc` для поиска документации по имени\n- Также он используется для snapshot теста `examples.test.mjs`\n\nКак Strudel выполняет [тестирование](/technical-manual/testing)?",
    "category": "technical-manual",
    "keywords": [
      "документация",
      "astro",
      "https",
      "github",
      "withastro",
      "tree",
      "main",
      "examples",
      "docs",
      "website",
      "pages",
      "learn",
      "code",
      "codeberg",
      "strudel",
      "branch",
      "http",
      "localhost",
      "sidebar",
      "config"
    ],
    "path": "technical-manual/docs.mdx"
  },
  {
    "id": "technical-manual-internals",
    "title": "Внутренние компоненты",
    "content": "# Внутренние функции\n\nЭти функции более низкого уровня, вероятно, не нужны live coder.\n\n# Haskell-подобные операции functor, applicative и monadic\n\n## withValue\n\n## appWhole\n\n## appBoth\n\n## appLeft\n\n## appRight\n\n## bindWhole\n\n## bind\n\n## join\n\n## outerBind\n\n## outerJoin\n\n## innerBind\n\n## innerJoin\n\n## resetJoin\n\n## restartJoin\n\n## squeezeJoin\n\n## squeezeBind\n\n# Утилитарные методы в основном для внутреннего использования\n\n## queryArc\n\n## splitQueries\n\n## withQuerySpan\n\n## withQuerySpanMaybe\n\n## withQueryTime\n\n## withHapSpan\n\n## withHapTime\n\n## withHaps\n\n## withHap\n\n## setContext\n\n## withContext\n\n## stripContext\n\n## withLoc\n\n## filterHaps\n\n## filterValues\n\n## removeUndefineds\n\n## onsetsOnly\n\n## discreteOnly\n\n## defragmentHaps\n\n## firstCycle\n\n## firstCycleValues\n\n## showFirstCycle\n\n## sortHapsByPart\n\n## asNumber\n\n# Операторы\n\n- \\_opIn\n- \\_opOut\n- \\_opMix\n- \\_opSqueeze\n- \\_opSqueezeOut\n- \\_opTrig\n- \\_opTrigzero\n\n# Прочее\n\n## onTrigger\n\n## log\n\n## logValues\n\n## drawLine\n\n## collect\n\n# Функции\n\n## groupHapsBy\n\n## pure\n\n## reify\n\n## slowcatPrime\n\n## isPattern\n\n## register\n\n## toBipolar\n\n## fromBipolar\n\n## compressSpan\n\n## focus\n\n## focusSpan\n\n## \\_composeOp\n\n# Composers\n\n```\nset keep keepif add sub mul div mod pow band bor bxor blshift brshift lt gt lte gte eq eqt ne net and or func\n```\n\n```\nIn Out Mix Squeeze SqueezeOut Trig Trigzero\n```",
    "category": "technical-manual",
    "keywords": [
      "внутренние",
      "компоненты",
      "live",
      "coder",
      "haskell",
      "functor",
      "applicative",
      "monadic",
      "withvalue",
      "appwhole",
      "appboth",
      "appleft",
      "appright",
      "bindwhole",
      "bind",
      "join",
      "outerbind",
      "outerjoin",
      "innerbind",
      "innerjoin"
    ],
    "path": "technical-manual/internals.mdx"
  },
  {
    "id": "technical-manual-packages",
    "title": "Packages Strudel",
    "content": "# Packages Strudel\n\n[Репозиторий strudel](https://codeberg.org/uzu/strudel) организован как monorepo, содержащий несколько npm packages.\nЦель множественных packages:\n\n- организовать кодовую базу на более модульные, инкапсулированные части\n- иметь возможность отказаться от определенных функциональностей\n- поддерживать зависимости core packages небольшими\n\n## Обзор\n\n[См. последние опубликованные packages на npm](https://www.npmjs.com/search?q=%40strudel).\nВот обзор всех packages:\n\n### Зонтичные Packages\n\nЭти packages дают вам полностью укомплектованную отправную точку, и, скорее всего, то, что вы хотите использовать в своем проекте:\n\n- [repl](https://codeberg.org/uzu/strudel/src/branch/main/packages/repl): Strudel REPL как веб-компонент.\n- [web](https://codeberg.org/uzu/strudel/src/branch/main/packages/web): Библиотека Strudel для браузера, без UI.\n\nЧтобы узнать больше об этих двух, прочитайте [Использование Strudel в вашем проекте](/technical-manual/project-start)\n\n### Основные Packages\n\nЭти packages наиболее важные. Вы можете захотеть использовать все из них, если используете strudel в своем проекте:\n\n- [core](https://codeberg.org/uzu/strudel/src/branch/main/packages/core#strudelcore): движок tidal pattern с базовыми примитивами\n- [mini](https://codeberg.org/uzu/strudel/src/branch/main/packages/mini#strudelmini): парсер mini notation + привязки к core\n- [transpiler](https://codeberg.org/uzu/strudel/src/branch/main/packages/transpiler#strudeltranspiler): транспилятор пользовательского кода. синтаксический сахар + подсветка\n\n### Языковые расширения\n\nЭти packages расширяют язык pattern специфическими функциями\n\n- [tonal](https://codeberg.org/uzu/strudel/src/branch/main/packages/tonal): функции tonal для гамм и аккордов\n- [xen](https://codeberg.org/uzu/strudel/src/branch/main/packages/xen): микротональные / ксеногармонические функции\n\n### Выходы\n\nЭти packages предоставляют привязки для различных способов вывода strudel patterns:\n\n- [webaudio](https://codeberg.org/uzu/strudel/src/branch/main/packages/webaudio#strudelwebaudio): вывод webaudio по умолчанию\n- [osc](https://codeberg.org/uzu/strudel/src/branch/main/packages/osc#strudelosc): привязки для коммуникации через OSC\n- [midi](https://codeberg.org/uzu/strudel/src/branch/main/packages/midi#strudelmidi): привязки webmidi\n- [csound](https://codeberg.org/uzu/strudel/src/branch/main/packages/csound#strudelcsound): привязки csound\n- [soundfonts](https://codeberg.org/uzu/strudel/src/branch/main/packages/serial#strudelsoundfonts): поддержка Soundfont\n- [serial](https://codeberg.org/uzu/strudel/src/branch/main/packages/serial#strudelserial): привязки webserial\n\n### Другие\n\n- [embed](https://codeberg.org/uzu/strudel/src/branch/main/packages/embed#strudelembed): встраиваемый REPL веб-компонент\n\n### Не поддерживаются\n\n- [react](https://www.npmjs.com/package/@strudel.cycles/react): react hooks и компоненты для strudel\n- [eval](https://www.npmjs.com/package/@strudel.cycles/eval): старый транспилятор кода\n- [tone](https://www.npmjs.com/package/@strudel.cycles/tone): привязки для инструментов и эффектов Tone.js\n- [webdirt](https://www.npmjs.com/package/@strudel.cycles/webdirt): привязки webdirt, заменены на webaudio package\n- любые `@strudel.cycles/*` packages были переименованы в `@strudel/*` начиная с версии 0.10.0.\n\n## Инструменты\n\n- [pnpm](https://pnpm.io/) для управления packages, workspaces и публикации\n- [lerna](https://lerna.js.org/) для обновления версий\n- см. CONTRIBUTING.md для получения дополнительной информации",
    "category": "technical-manual",
    "keywords": [
      "packages",
      "strudel",
      "https",
      "codeberg",
      "monorepo",
      "core",
      "npmjs",
      "search",
      "repl",
      "branch",
      "main",
      "technical",
      "manual",
      "project",
      "start",
      "strudelcore",
      "tidal",
      "pattern",
      "mini",
      "strudelmini"
    ],
    "path": "technical-manual/packages.mdx"
  },
  {
    "id": "technical-manual-patterns",
    "title": "Patterns",
    "content": "# Patterns\n\nPatterns являются сущностью Tidal. Его patterns - это абстрактные сущности, представляющие потоки времени в виде функций, адаптируя технику, называемую чистым функциональным реактивным программированием. Принимая временной диапазон в качестве входных данных, Pattern может выдавать набор событий, которые происходят в течение этого временного диапазона. От структуры Pattern зависит, как события расположены во времени.\nС этого момента этот процесс генерации событий из временного диапазона будет называться **запросом** (querying).\nПример:\n\nВ этом примере мы создаем pattern с помощью функции `sequence` и **запрашиваем** его для временного диапазона от `0` до `1`.\nЭти числа представляют единицы времени, называемые **cycles**. Длина одного cycle зависит от темпа, который по умолчанию равен одному cycle в секунду.\nПолученные события:\n\n```js\n[\n  '[ 0/1 -> 1/2 | c3 ]', //\n  '[ 1/2 -> 3/4 | e3 ]',\n  '[ 3/4 -> 1/1 | g3 ]',\n];\n```\n\nКаждое событие имеет значение, время начала и время окончания, где время представлено в виде дроби. В приведенном выше случае события размещены в последовательном порядке, где c3 занимает первую половину, а e3 и g3 вместе занимают вторую половину. Это временное размещение является результатом функции `sequence`, которая делит свои аргументы поровну на один cycle. Если аргумент является массивом, то же правило применяется к этой части cycle. В примере e3 и g3 делятся поровну на вторую половину всего cycle.\n\nОбратите внимание, что функция query - это не просто способ доступа к pattern, а в соответствии с принципами функционального программирования, является самим pattern. Это означает, что теоретически нет способа изменить pattern, он непрозрачен как чистая функция. На практике же Strudel и Tidal - это все о трансформации patterns, так как же это делается? Ответ - заменой pattern новым, который вызывает старый. Этот новый способен только манипулировать запросом перед передачей его старому pattern и манипулировать результатами от него перед их возвратом вызывающей стороне. Но этого достаточно для поддержки всех временных и структурных манипуляций, предоставляемых обширной библиотекой функций Strudel (и Tidal).\n\nПриведенные выше примеры не представляют, как Strudel используется на практике. В редакторе live coding пользователю нужно только ввести сам pattern, запрос будет обработан планировщиком (scheduler). Планировщик будет многократно запрашивать pattern для событий, которые затем планируются как синтез звука или другие триггеры событий.\n\nМожем ли мы [выравнивать](/technical-manual/alignment) patterns?",
    "category": "technical-manual",
    "keywords": [
      "patterns",
      "tidal",
      "pattern",
      "querying",
      "sequence",
      "cycles",
      "cycle",
      "query",
      "strudel",
      "live",
      "coding",
      "scheduler",
      "technical",
      "manual",
      "alignment"
    ],
    "path": "technical-manual/patterns.mdx"
  },
  {
    "id": "technical-manual-project-start",
    "title": "Использование Strudel в вашем проекте",
    "content": "# Использование Strudel в вашем проекте\n\nЭто руководство показывает различные способы начать использовать Strudel в вашем собственном проекте.\n\n## Соблюдайте лицензию\n\nВо-первых, пожалуйста, уделите время, чтобы понять свободную/открытую лицензию Strudel,\n[AGPL-3.0](https://www.gnu.org/licenses/agpl-3.0.en.html).\n\nВот краткое изложение, но проверьте лицензию на юридические определения и обязанности.\n\n- Вы можете распространять измененные версии, если отслеживаете изменения и дату их внесения.\n- Вы должны лицензировать производную работу под той же лицензией.\n- Исходный код должен распространяться вместе с веб-публикацией.\n\nСреди прочего, это означает, что когда вы делитесь своей работой, все приложение должно быть распространено под той же свободной/открытой лицензией или совместимой с ней. Это потому, что мы хотим, чтобы Strudel оставался свободным/открытым. Другими словами, вам не разрешается распространять интеграции Strudel с библиотеками или другим кодом, который не имеет совместимой свободной/открытой лицензии.\n\nЭто также применяется к клонам, созданным на основе чтения исходного кода Strudel, поскольку с юридической точки зрения это считается 'производной работой'. Опять же, пожалуйста, [прочитайте лицензию](https://www.gnu.org/licenses/agpl-3.0.en.html) для деталей.\n\n## Встраивание Strudel REPL\n\nЕсть 3 быстрых способа встроить strudel на ваш веб-сайт:\n\n1. Встроить веб-сайт strudel как iframe напрямую\n2. Встроить веб-сайт strudel как iframe, используя `@strudel/embed`\n3. Встроить REPL напрямую, используя `@strudel/repl`\n\n### Внутри iframe\n\nИспользование iframe - самый простой способ встроить мелодию strudel.\nВы можете встроить любой pattern на ваш выбор через iframe и URL pattern на ваш выбор:\n\n```html\n<iframe src=\"https://strudel.cc/?xwWRfuCE8TAR\" width=\"600\" height=\"300\"></iframe>\n```\n\nURL можно получить, нажав `share` в REPL.\nОбратите внимание, что эти ссылки для обмена зависят от базы данных, которая не гарантированно будет существовать вечно.\nЧтобы убедиться, что ваш код не потерян, вы также можете использовать длинный URL:\n\n```html\n<iframe\n  src=\"https://strudel.cc/#c2V0Y3BzKDEpCm4oIjwwIDEgMiAzIDQ%2BKjgiKS5zY2FsZSgnRzQgbWlub3InKQoucygiZ21fbGVhZF82X3ZvaWNlIikKLmNsaXAoc2luZS5yYW5nZSguMiwuOCkuc2xvdyg4KSkKLmp1eChyZXYpCi5yb29tKDIpCi5zb21ldGltZXMoYWRkKG5vdGUoIjEyIikpKQoubHBmKHBlcmxpbi5yYW5nZSgyMDAsMjAwMDApLnNsb3coNCkp\"\n  width=\"600\"\n  height=\"300\"\n></iframe>\n```\n\nЭтот длинный URL можно просто скопировать из адресной строки, когда вы находитесь на веб-сайте strudel. Он всегда отражает последнее выполнение вашего кода.\n\n### @strudel/embed\n\nЧтобы упростить процесс встраивания через iframe, вы можете использовать package `@strudel/embed`:\n\n```html\n<script src=\"https://unpkg.com/@strudel/embed@latest\"></script>\n<strudel-repl>\n  <!--\nsetcps(1)\nn(\"<0 1 2 3 4>*8\").scale('G4 minor')\n.s(\"gm_lead_6_voice\")\n.clip(sine.range(.2,.8).slow(8))\n.jux(rev)\n.room(2)\n.sometimes(add(note(\"12\")))\n.lpf(perlin.range(200,20000).slow(4))\n-->\n</strudel-repl>\n```\n\nЭто загрузит веб-сайт strudel в iframe, используя код, предоставленный в HTML-комментариях `<!-- -->`.\nHTML-комментарии необходимы, чтобы браузер не интерпретировал его как HTML.\n\nДля альтернативных способов загрузки этого package см. [@strudel/embed README](https://codeberg.org/uzu/strudel/src/branch/main/packages/embed#strudel-embed).\n\n### @strudel/repl\n\nЗагрузка strudel напрямую на ваш сайт, без iframe, выглядит похоже на вариант с iframe:\n\n```html\n<script src=\"https://unpkg.com/@strudel/repl@latest\"></script>\n<strudel-editor>\n  <!--\nsetcps(1)\nn(\"<0 1 2 3 4>*8\").scale('G4 minor')\n.s(\"gm_lead_6_voice\")\n.clip(sine.range(.2,.8).slow(8))\n.jux(rev)\n.room(2)\n.sometimes(add(note(\"12\")))\n.lpf(perlin.range(200,20000).slow(4))\n-->\n</strudel-editor>\n```\n\nЗдесь мы загружаем `@strudel/repl` вместо `@strudel/embed`, и компонент называется `strudel-editor` вместо `strudel-repl`.\nДа, именование немного запутанное..\n\nПреимущество использования repl без iframe заключается в том, что вы можете закрепить используемую версию strudel:\n\n```html\n<script src=\"https://unpkg.com/@strudel/repl@1.0.2\"></script>\n<strudel-editor>\n  <!--\n...\n-->\n</strudel-editor>\n```\n\nЭто гарантирует, что ваш pattern не сломается из-за изменений в проекте strudel в будущем.\n\nДля получения дополнительной информации об этом package см. [@strudel/repl README](https://codeberg.org/uzu/strudel/src/branch/main/packages/repl#strudel-repl).\n\n## С вашим собственным UI\n\nПриведенный выше подход предполагает, что вы хотите использовать встроенный редактор [codemirror](https://codemirror.net/).\nЕсли вы предпочитаете использовать свой собственный UI, вы можете использовать package `@strudel/web`:\n\n```html\n<!doctype html>\n<script src=\"https://unpkg.com/@strudel/web@1.0.3\"></script>\n<button id=\"play\">play</button>\n<button id=\"stop\">stop</button>\n<script>\n  initStrudel();\n  document.getElementById('play').addEventListener('click', () => note('<c a f e>(3,8)').jux(rev).play());\n  document.getElementById('stop').addEventListener('click', () => hush());\n</script>\n```\n\nДля получения дополнительной информации об этом package см. [@strudel/web README](https://codeberg.org/uzu/strudel/src/branch/main/packages/web#strudel-web).\n\n## Через npm\n\n[Все packages и многие другие доступны на npm под namespace @strudel](https://www.npmjs.com/search?q=%40strudel).\nНа самом деле есть гораздо больше packages, которые вы можете использовать, чтобы иметь детальный контроль над тем, что вы используете, а что нет.\nЧтобы использовать эти packages, вы должны использовать bundler, который поддерживает es modules, например [vite](https://vitejs.dev/).\n\nЧтобы узнать больше о назначении каждого package, см. [Packages](/technical-manual/packages)",
    "category": "technical-manual",
    "keywords": [
      "использование",
      "strudel",
      "вашем",
      "проекте",
      "setcps",
      "scale",
      "clip",
      "range",
      "slow",
      "jux",
      "room",
      "sometimes",
      "add",
      "note",
      "lpf",
      "initstrudel",
      "getelementbyid",
      "addeventlistener",
      "play",
      "hush"
    ],
    "path": "technical-manual/project-start.mdx"
  },
  {
    "id": "technical-manual-repl",
    "title": "REPL",
    "content": "# REPL\n\n{/* [REPL](https://strudel.cc/) - это место, где все packages собираются вместе, образуя систему live coding. Его также можно рассматривать как эталонную реализацию для пользователей библиотеки. */}\n\nХотя Strudel можно использовать как библиотеку в любой кодовой базе JavaScript, его основным справочным пользовательским интерфейсом является Strudel REPL[^1], который является браузерной средой live coding. Этот редактор live code предназначен для манипулирования Strudel patterns во время их воспроизведения. REPL имеет встроенную визуальную обратную связь, подсвечивая, какие элементы в pattern (mini-notation) последовательностях влияют на событие, которое в данный момент воспроизводится. Эта обратная связь разработана для поддержки как обучения, так и живого использования Strudel.\n\n[^1]: REPL расшифровывается как read, evaluate, print/play, loop (читать, оценивать, печатать/воспроизводить, цикл). Это дружественный жаргон для интерактивного программного интерфейса из наследия вычислений, обычно для интерфейса командной строки, но также применяется к редакторам live coding.\n\nПомимо UI для управления воспроизведением и мета-информации, основной частью интерфейса REPL является редактор кода на базе CodeMirror. В нем пользователь может редактировать и оценивать код pattern вживую, используя один из доступных выходов синтеза для создания музыки и/или звукового искусства. Поток управления REPL следует 3 основным шагам:\n\n1. Пользователь пишет и обновляет код. Каждое обновление транспилирует и оценивает его для создания экземпляра `Pattern`\n2. Пока REPL работает, `Scheduler` запрашивает активный `Pattern` с регулярным интервалом, генерируя `Events` (также известные как `Haps` в Strudel) для следующего временного диапазона.\n3. Для каждого тика планирования все сгенерированные `Events` запускаются путем вызова их метода `onTrigger`, который устанавливается выходом.\n\n<img src=\"https://codeberg.org/uzu/strudel/raw/branch/talk/talk/public/strudelflow.png\" width=\"600\" />\n\n## Пользовательский код\n\nЧтобы создать `Pattern` из пользовательского кода, необходимы два шага:\n\n1. Транспилировать входной JS код, чтобы сделать его функциональным\n2. Оценить транспилированный код\n\n### Транспиляция и оценка\n\nВ мире JavaScript использование транспиляции является обычной практикой, чтобы иметь возможность использовать языковые функции, которые не поддерживаются базовым языком. Такие инструменты, как `babel`, будут транспилировать код, содержащий неподдерживаемые языковые функции, в версию кода без этих функций.\n\nВ той же традиции Strudel может добавить шаг транспиляции для упрощения пользовательского кода в контексте live coding. Например, Strudel REPL позволяет пользователю создавать mini-notation patterns, используя только строки в двойных кавычках, в то время как строки в одинарных кавычках остаются тем, чем они являются:\n\n```strudel\nnote(\"c3 [e3 g3]*2\")\n```\n\nтранспилируется в:\n\n```strudel\nnote(m('c3 [e3 g3]', 5))\n```\n\nЗдесь строка обернута в `m`, который создаст pattern из строки mini-notation. В качестве второго параметра передается расположение исходного кода строки, что позволяет подсвечивать активные события позже.\n\nПосле транспиляции код готов к оценке в `Pattern`.\n\nЗа кулисами строка пользовательского кода парсится с помощью `acorn`, превращаясь в абстрактное синтаксическое дерево (AST). AST позволяет изменять структуру кода перед генерацией транспилированной версии с помощью `escodegen`.\n\n### Mini-notation\n\nХотя транспиляция позволяет JavaScript выражать Patterns менее многословным способом, все же предпочтительнее использовать mini-notation как более компактный способ выражения ритма. Strudel стремится предоставить те же функции и синтаксис mini-notation, что и в Tidal.\n\nПарсер mini-notation реализован с помощью `peggy`, который позволяет генерировать производительные парсеры для доменных языков (DSL) с использованием краткой грамматической нотации. Сгенерированный парсер превращает строку mini-notation в AST, который используется для вызова соответствующих функций Strudel с заданной структурой. Например, `\"c3 [e3 g3]*2\"` приведет к следующим вызовам:\n\n```strudel\nseq(\n  reify('c3').withLoc(6, 9),\n  seq(reify('e3').withLoc(10, 12), reify('g3',).withLoc(13, 15))\n)\n```\n\n### Подсветка расположений\n\nКак видно в примерах выше, как транспилятор, так и парсер mini-notation добавляет расположение исходного кода, используя `withLoc`.\nЭто расположение вычисляется внутри функции `m` как сумма 2 расположений:\n\n1. расположение, где начинается строка mini notation, полученное из JS парсера\n2. расположение подстроки внутри mini notation, полученное из парсера mini notation\n\nСумма обоих передается в `withLoc`, чтобы сообщить каждому элементу его расположение, которое может быть позже использовано для подсветки, когда он активен.\n\n### Mini Notation\n\nДругая важная часть пользовательского кода - это mini notation, которая позволяет выражать ритмы кратким образом.\n\n- mini notation [реализована как PEG грамматика](https://codeberg.org/uzu/strudel/src/branch/talk/packages/mini/krill.pegjs), находящаяся в [mini package](https://codeberg.org/uzu/strudel/src/branch/main/packages/mini)\n- она основана на [krill](https://github.com/Mdashdotdashn/krill) от Mdashdotdashn\n- peg грамматика используется для генерации парсера с помощью [peggyjs](https://peggyjs.org/)\n- сгенерированный парсер берет строку mini notation и выдает AST\n- AST затем может быть использовано для построения pattern с использованием обычного Strudel API\n\nВот пример AST для `c3 [e3 g3]`\n\n```json\n{\n  \"type_\": \"pattern\",\n  \"arguments_\": { \"alignment\": \"h\" },\n  \"source_\": [\n    {\n      \"type_\": \"element\", \"source_\": \"c3\",\n      \"location_\": { \"start\": { \"offset\": 1, \"line\": 1, \"column\": 2 }, \"end\": { \"offset\": 4, \"line\": 1, \"column\": 5 } }\n    },\n    {\n      \"type_\": \"element\",\n      \"location_\": { \"start\": { \"offset\": 4, \"line\": 1, \"column\": 5 }, \"end\": { \"offset\": 11, \"line\": 1, \"column\": 12 } }\n      \"source_\": {\n        \"type_\": \"pattern\", \"arguments_\": { \"alignment\": \"h\" },\n        \"source_\": [\n          {\n            \"type_\": \"element\", \"source_\": \"e3\",\n            \"location_\": { \"start\": { \"offset\": 5, \"line\": 1, \"column\": 6 }, \"end\": { \"offset\": 8, \"line\": 1, \"column\": 9 } }\n          },\n          {\n            \"type_\": \"element\", \"source_\": \"g3\",\n            \"location_\": { \"start\": { \"offset\": 8, \"line\": 1, \"column\": 9 }, \"end\": { \"offset\": 10, \"line\": 1, \"column\": 11 } }\n          }\n        ]\n      },\n    }\n  ]\n}\n```\n\nкоторый переводится в `seq(c3, seq(e3, g3))`\n\n## Vim горячие клавиши\n\nСм. отдельную страницу о горячих клавишах Vim для быстрого справочника: [/technical-manual/vim](/technical-manual/vim)\n\n## Планирование событий\n\nПосле получения экземпляра `Pattern` из пользовательского кода, он используется планировщиком для запроса событий. После запуска планировщик выполняется с фиксированным интервалом для запроса активного pattern на предмет событий в пределах временного диапазона текущего интервала. Упрощенная реализация выглядит так:\n\n```js\nlet pattern = seq('c3', ['e3', 'g3']); // pattern от пользователя\nlet interval = 0.5; // интервал запроса в секундах\nlet time = 0; // начало текущего временного диапазона\nlet minLatency = 0.1; // минимальное время до того, как hap должен сработать\nsetInterval(() => {\n  const haps = pattern.queryArc(time, time + interval);\n  time += interval; // увеличить время\n  haps.forEach((hap) => {\n    const deadline = hap.whole.begin - time + minLatency;\n    onTrigger(hap, deadline, duration);\n  });\n}, interval * 1000); // запрос каждые \"interval\" секунд\n```\n\nОбратите внимание, что приведенный выше код упрощен в иллюстративных целях. Фактическая реализация должна обходить неточные обратные вызовы `setInterval`. Подробнее о деталях реализации можно прочитать в [этом блог-посте](https://loophole-letters.vercel.app/web-audio-scheduling).\n\nТот факт, что `Pattern.queryArc` является чистой функцией, которая отображает временной диапазон на набор событий, позволяет нам выбрать любой интервал, к",
    "category": "technical-manual",
    "keywords": [
      "repl",
      "note",
      "seq",
      "reify",
      "withloc",
      "setinterval",
      "queryarc",
      "foreach",
      "ontrigger",
      "cutoff",
      "map",
      "createparams",
      "range",
      "getaudiocontext",
      "createoscillator",
      "getfreq",
      "start",
      "stop",
      "connect",
      "https"
    ],
    "path": "technical-manual/repl.mdx"
  },
  {
    "id": "technical-manual-sounds",
    "title": "Звуки",
    "content": "# Звуки\n\nДавайте подробнее рассмотрим, как звуки реализованы в выводе webaudio.\n\n## Регистрация звука\n\nВсе звуки регистрируются в карте звуков, используя функцию `registerSound`:\n\n```ts\nfunction registerSound(\n  name: string, // Имя звука, которое должно быть передано в `s`, например `mysaw`\n  // Функция, вызываемая планировщиком для запуска звука:\n  (\n    time: number, // Время audio context, когда звук должен начаться\n    value: object, // Значение `Hap`\n    onended: () => void // Обратный вызов, который должен быть вызван, когда звук закончился\n  ) => {\n    node: AudioNode, // node для подключения к остальной цепи эффектов\n    stop: (time:number) => void // функция, которая остановит звук\n  },\n  data: object // мета-данные, только для логики ui во вкладке звуков\n);\n```\n\nКогда вызывается `registerSound`, он регистрирует `{ onTrigger, data }` под заданным `name` в [nanostore map](https://github.com/nanostores/nanostores#maps).\n\n### Пример\n\nЭто может быть немного абстрактно, поэтому вот минимальный пример:\n\n```js\nregisterSound(\n  'mysaw',\n  (time, value, onended) => {\n    let { freq } = value; // деструктуризация контрольных параметров\n    const ctx = getAudioContext();\n    // создать осциллятор\n    const o = new OscillatorNode(ctx, { type: 'sawtooth', frequency: Number(freq) });\n    o.start(time);\n    // добавить gain node для снижения уровня osc\n    const g = new GainNode(ctx, { gain: 0.3 });\n    // подключить osc к gain\n    const node = o.connect(g);\n    // эту функцию можно вызвать извне для остановки звука\n    const stop = (time) => o.stop(time);\n    // ended будет вызван, когда stop был вызван\n    o.addEventListener('ended', () => {\n      o.disconnect();\n      g.disconnect();\n      onended();\n    });\n    return { node, stop };\n  },\n  { type: 'synth' },\n);\n// использовать звук\nfreq(220, 440, 330).s('mysaw');\n```\n\nВы можете фактически использовать этот код в [REPL](https://strudel.cc/) и он будет работать.\nПосле оценки кода вы должны увидеть `mysaw` в списке во вкладке звуков.\n\n## Воспроизведение звуков\n\nТеперь вот что происходит, когда звук воспроизводится:\nКогда вывод webaudio воспроизводит `Hap`, он найдет и вызовет функцию `onTrigger` для заданного `s`.\nВозвращенный `node` затем может быть подключен к остальной стандартной цепи эффектов\nНаличие отдельной функции stop позволяет воспроизводить звуки через midi тоже, где вы не знаете, как долго будет длиться noteon",
    "category": "technical-manual",
    "keywords": [
      "звуки",
      "registersound",
      "getaudiocontext",
      "start",
      "connect",
      "stop",
      "addeventlistener",
      "disconnect",
      "onended",
      "freq",
      "webaudio",
      "function",
      "name",
      "string",
      "mysaw",
      "time",
      "number",
      "audio",
      "context",
      "value"
    ],
    "path": "technical-manual/sounds.mdx"
  },
  {
    "id": "technical-manual-testing",
    "title": "Тестирование",
    "content": "# Тестирование\n\nStrudel использует [vitest](https://vitest.dev/) для тестирования с 2 типами стратегий тестирования:\n\n- модульные тесты для детального тестирования\n- автоматизированные snapshot тесты для более широкого тестирования\n\n## Модульные тесты\n\nКаждый package имеет папку `test`, где тесты написаны на основе файла за файлом, например `util.test.mjs` реализует все тесты для `util.mjs`.\n\n## Snapshot тесты\n\nSnapshot тесты позволяют тестировать большие фрагменты данных. Strudel использует snapshot тесты для:\n\n- Примеров фрагментов: `examples.test.mjs`, используя фрагменты под `@example` внутри jsdoc комментариев\n- Примеров мелодий: `tunes.test.mjs`, используя все patterns в `tunes.mjs`\n\nФайлы snapshot (`.snap`) содержат все haps в пределах определенного количества cycles для каждого тестируемого pattern.\nОни позволяют тестировать критические изменения в более широком масштабе.\nЕсли критические изменения преднамеренны, snapshots можно обновить с помощью `npm run snapshot`.\nПросто убедитесь, что проверили, что все затронутые patterns ведут себя как ожидалось.",
    "category": "technical-manual",
    "keywords": [
      "тестирование",
      "strudel",
      "vitest",
      "https",
      "snapshot",
      "package",
      "test",
      "util",
      "examples",
      "example",
      "jsdoc",
      "tunes",
      "patterns",
      "snap",
      "haps",
      "cycles",
      "pattern",
      "snapshots"
    ],
    "path": "technical-manual/testing.mdx"
  },
  {
    "id": "technical-manual-vim",
    "title": "Горячие клавиши Vim",
    "content": "# Горячие клавиши Vim в REPL\n\nКогда редактор REPL (CodeMirror) настроен на использование горячих клавиш Vim, доступны следующие команды:\n\n- :w — Оценить текущий код\n\n  - Запускает ту же оценку, что и Ctrl+Enter / Alt+Enter\n  - Вы увидите сообщения в панели Console такие как:\n    - [vim] :w — evaluating code\n    - [repl] evaluate via event\n    - [eval] code updated\n\n- :q — Остановить/приостановить воспроизведение\n\n  - Запускает то же действие остановки, что и Alt+.\n  - Полезно для быстрой остановки планирования без выхода из режима Vim\n\n- gc — Переключить комментарии строк для текущего выделения\n\n  - Работает в обычном и визуальном режимах\n  - Если есть выделение, все выбранные строки переключаются\n\nПримечания\n\n- Поведение учитывает текущий языковой режим в редакторе для синтаксиса комментариев.\n- Если открыто несколько редакторов REPL, команды нацелены на активный редактор. Реализация отправляет пользовательские события, обрабатываемые редактором.\n- Если вы не видите панель Console, откройте правую панель в UI REPL.\n\nУстранение неполадок\n\n- Если :w записывает в лог, но оценка не применяется, убедитесь, что горячие клавиши Vim активны, и попробуйте снова. Вы также можете использовать Ctrl+Enter в качестве запасного варианта.\n- Для :q / gc убедитесь, что фокус находится внутри редактора. Если возникает ошибка, перезагрузите страницу, чтобы сбросить состояние редактора, и попробуйте снова.",
    "category": "technical-manual",
    "keywords": [
      "горячие",
      "клавиши",
      "vim",
      "repl",
      "codemirror",
      "ctrl",
      "enter",
      "console",
      "evaluating",
      "code",
      "evaluate",
      "event",
      "eval",
      "updated"
    ],
    "path": "technical-manual/vim.mdx"
  },
  {
    "id": "understand-cycles",
    "title": "Понимание Cycles",
    "content": "# Понимание Cycles\n\nКонцепция cycles является центральной для понимания того, как работает Strudel.\nМатеринский язык Strudel, TidalCycles, даже имеет это в своем названии.\n\n## Cycles и BPM\n\nВ большинстве музыкальных программ для установки темпа используется единица BPM (ударов в минуту).\nStrudel выражает темп как CPS (cycles в секунду), по умолчанию 0.5 CPS:\n\nЗдесь мы можем услышать 0.5CPS в действии: Бочка повторяется один раз каждые две секунды.\nДавайте сделаем 4 бочки:\n\nТеперь у нас 4 бочки на cycle, но весь pattern все еще воспроизводится на 0.5CPS.\nС точки зрения BPM, большинство музыкантов скажут вам, что это воспроизводится на 120bpm.\nА как насчет этого:\n\nПоскольку второй звук теперь хай-хэт, темп снова ощущается медленнее.\nЭто приводит нас к важному осознанию:\n\n## Установка CPM\n\nЕсли вы знакомы с BPM, вы можете использовать метод `setcpm` для установки глобального темпа в cycles в минуту:\n\nЕсли вы хотите добавить больше ударов на cycle, вы можете разделить cpm:\n\nИли используя 2 удара на cycle:\n\nВы можете использовать метод `setcps` для установки глобального темпа в cycles в секунду. `setcpm(x)` это то же самое, что `setcps(x / 60)`.\n\n## Cycles и такты\n\nТакже в большинстве музыкальных программ несколько ударов образуют такт (или меру).\nТак называемый размер такта определяет, сколько ударов в каждом такте.\nВо многих типах музыки обычно используется 4 удара на такт, также известный как размер 4/4.\nМногие музыкальные программы используют его по умолчанию.\n\nStrudel не имеет концепции тактов или мер, есть только cycles.\nКак вы их используете - решать вам. Выше у нас был этот пример:\n\nЭто можно интерпретировать как размер 4/4 с темпом 110bpm.\nМы могли бы написать несколько тактов так:\n\nВместо того чтобы выписывать каждый такт отдельно, мы могли бы выразить это гораздо короче:\n\nЗдесь мы можем видеть, что мышление в cycles, а не в тактах, значительно упрощает дело!\nЭти типы упрощений работают из-за повторяющейся природы ритма.\nВ вычислительных терминах можно сказать, что прежняя нотация имеет много избыточности.\n\n## Размеры такта\n\nЧтобы получить размер такта, просто измените количество элементов на такт. Вот ритм с 7 ударами:\n\nили с 5:\n\nМы также могли бы написать несколько тактов с разными размерами:\n\nЗдесь мы переключаемся между 3/4 и 4/4, сохраняя один и тот же темп.\n\nЕсли мы не указываем длину, мы получаем то, что называется метрической модуляцией:\n\nТеперь 3 элемента получают то же время, что и 4 элемента, поэтому темп меняется.",
    "category": "understand",
    "keywords": [
      "понимание",
      "cycles",
      "setcpm",
      "setcps",
      "strudel",
      "tidalcycles",
      "cycle",
      "pattern"
    ],
    "path": "understand/cycles.mdx"
  },
  {
    "id": "understand-pitch",
    "title": "Понимание Pitch",
    "content": "# Понимание Pitch\n\nДавайте узнаем, как работает pitch! Ползунок ниже управляет <span style=\"color:#3b82f6;\">частотой</span> осциллятора, производя pitch:\n\n{/*  */}\n\n- Перетащите ползунок, чтобы услышать pitch\n- Переместите ползунок, чтобы изменить pitch\n- Наблюдайте, как меняется число Hz\n- <span className=\"text-red-300\">Осторожно</span>: Более высокие частоты могут быть неприятны для детей или животных!\n\nЧисло Hz - это частота pitch, которую вы слышите.\nЧем выше частота, тем выше pitch, и наоборот.\nPitch возникает, когда что-то вибрирует / колеблется с определенной частотой, в данном случае это ваш динамик.\nЕдиница **Hz** описывает, сколько раз эта осцилляция происходит в секунду.\nНаши глаза слишком медленные, чтобы на самом деле увидеть осцилляцию на динамике, но мы можем <a href=\"https://www.youtube.com/watch?v=CDMBWw7OuJQ\" target=\"_blank\">увидеть это в замедленной съемке</a>.\n\nВ Strudel мы можем воспроизводить частоты напрямую с помощью контрола `freq`:\n\n## Частота против восприятия Pitch\n\nВозможно, вы уже заметили, что <span style=\"color:#3b82f6;\">ползунок частоты</span> \"несимметричный\",\nчто означает, что pitch больше меняется в левой области и меньше в правой области.<br/>\nЧтобы сделать это более очевидным, давайте добавим <span style=\"color:#eab308\">ползунок pitch</span>,\nкоторый управляет частотой по другой шкале:\n\nПопробуйте кнопки выше, чтобы прокрутить диапазон частот двумя разными способами:\n\n- Развертка частоты: <span style=\"color:#3b82f6;\">частота растет линейно</span> , <span style=\"color:#eab308\">pitch растет логарифмически</span>\n- Развертка Pitch: <span style=\"color:#3b82f6;\">частота растет экспоненциально</span> , <span style=\"color:#eab308\">pitch растет линейно</span>\n\nВ большинстве случаев мы можем захотеть управлять pitch таким образом, который соответствует нашему восприятию,\nчто и делает <span style=\"color:#eab308\">ползунок pitch</span>.\n\n## От Hz к полутонам\n\nПоскольку Hz не соответствует нашему восприятию, давайте попробуем найти единицу для pitch, которая соответствует.\nЧтобы приблизиться к этой единице pitch, давайте посмотрим, как ведет себя частота, когда она удваивается:\n\n- Используйте ступенчатый ползунок pitch выше\n- Слышите ли вы, как эти питчи связаны друг с другом?\n\nПоскольку октавы довольно далеко друг от друга, октавы обычно делятся на 12 меньших частей:\n\nЭтот шаг также называется полутоном, который является наиболее распространенным делением pitch-музыки.\nНапример, клавиши на клавиатуре пианино также разделены на полутоны.\n\nВ Strudel мы могли бы сделать это с `freq` так:\n\nКонечно, это можно написать короче с помощью note, как мы увидим ниже.\n\n## От полутонов к MIDI-номерам\n\nТеперь мы знаем, что такое расстояние полутона.\nВыше мы использовали произвольную базовую частоту 440Hz, что означает, что экспонента 0 равна 440Hz.\nОбычно 440Hz стандартизирован до числа 69, что приводит к этому расчету:\n\nЖелтое число теперь является MIDI-номером, охватывающим более чем весь диапазон человеческого слуха с числами от 0 до 127.\nВ Strudel мы можем использовать MIDI-номера внутри `note`:\n\n## От MIDI-номеров к нотам\n\nВ западной музыкальной теории вместо номеров используются ноты.\nДля каждого midi-номера есть по крайней мере одна нотная метка:\n\nПолная нотная метка состоит из буквы (A-G), 0 или более знаков альтерации (b | #) и номера октавы.\nЭта система также известна как [научная нотация pitch](https://en.wikipedia.org/wiki/Scientific_pitch_notation).\nВ Strudel эти нотные метки также могут использоваться внутри `note` как альтернатива midi-номерам:\n\n## Открытые вопросы\n\nТеперь, когда мы узнали о различных представлениях pitch, все еще остаются открытые вопросы:\n\n- Почему 12 нот? А как насчет других делений октавы?\n- Почему ноты обозначены так, как они есть? Почему только 7 букв?\n- Есть ли другие системы обозначений?\n- А как насчет систем чистого строя?\n- А как насчет тембра?\n\nВсе эти вопросы важно задавать, и на них будут даны ответы в другой статье.\n\n## Определение\n\nСначала я хотел начать эту статью с определения, но затем подумал, что было бы хорошей идеей сосредоточиться на интуитивном исследовании.\nВозможно, теперь вы понимаете это определение намного лучше:",
    "category": "understand",
    "keywords": [
      "понимание",
      "pitch",
      "span",
      "style",
      "color",
      "classname",
      "text",
      "href",
      "https",
      "youtube",
      "watch",
      "target",
      "strudel",
      "freq",
      "note",
      "midi",
      "wikipedia",
      "wiki"
    ],
    "path": "understand/pitch.mdx"
  },
  {
    "id": "understand-voicings",
    "title": "Понимание аккордовых Voicings",
    "content": "# Понимание аккордов и Voicings\n\nДавайте глубже погрузимся в то, как работают аккорды и voicings в strudel.\nЯ постараюсь свести теоретический жаргон к минимуму, так что, надеюсь, это будет доступно для всех заинтересованных.\n\n## Что такое аккорд\n\nИгра более чем одной ноты одновременно обычно называется `аккордом`. Вот пример:\n\nВот то же самое с midi-номерами:\n\nЗдесь у нас два 3-нотных аккорда, воспроизводимых в цикле.\nВы могли бы уже остановиться здесь и писать аккорды в этом стиле, что вполне нормально и дает вам контроль над отдельными нотами.\nОдин недостаток заключается в том, что может быть сложно найти хорошо звучащие аккорды, и, возможно, вы жаждете какого-то другого способа организации аккордов.\n\n## Обозначение аккордов\n\nАккорды обычно получают разные метки в зависимости от соотношения нот внутри.\nВ числовом примере выше у нас есть `48,51,55` и `53,57,60`.\n\nЧтобы проанализировать соотношение этих нот, их обычно сравнивают с каким-то `основным тоном`, который часто является самой низкой нотой.\nВ нашем случае `основными тонами` будут `48` (= `c3`) и `53` (= `f3`).\nМы можем выразить те же аккорды относительно этих `основных тонов` так:\n\nТеперь внутри каждого аккорда каждое число представляет расстояние от основного тона.\nРасстояние между питчами обычно называется `интервалом`, но пока давайте будем придерживаться понятия расстояние.\n\nТеперь мы видим, что наши 2 аккорда на самом деле довольно похожи, так как единственное различие - средняя нота (и основной тон, конечно).\nОни являются частью группы аккордов, называемых `трезвучиями`, которые являются аккордами с 3 нотами.\n\n### Трезвучия\n\nЭти 4 формы являются наиболее распространенными типами `трезвучий`, с которыми вы столкнетесь:\n\n| форма | обозначение    |\n| ----- | -------------- |\n| 0,4,7 | мажорное       |\n| 0,3,7 | минорное       |\n| 0,3,6 | уменьшенное    |\n| 0,4,8 | увеличенное    |\n\nВот они по порядку:\n\nМногие типы музыки часто используют только минорные и мажорные аккорды, так что у нас уже есть знания для аккомпанемента песен. Вот одна из них:\n\nЭто аккорды для \"The House of the Rising Sun\" группы The Animals.\nПока это звучит не слишком захватывающе, но, по крайней мере, узнаваемо.\n\n## Voicings\n\n`Voicing` - это один из многих способов расположения определенной формы аккорда.\nТермин происходит из хоровой музыки, где аккорды могут быть спеты по-разному путем назначения разных нот каждому голосу.\nНапример, мы могли бы добавить 12 полутонов к одной или нескольким нотам в аккорде:\n\nНоты, находящиеся на расстоянии 12 полутоновых шагов (= 1 `октава`), считаются равными в гармоническом смысле, поэтому они получают одну и ту же нотную букву.\nВот тот же пример с нотными буквами:\n\nЭти типы voicings также называются `обращениями`. Существует много других способов, которыми мы могли бы `озвучить` этот минорный аккорд:\n\nЗдесь мы немного меняем вкус аккорда путем\n\n1. удвоения нот на 12 шагов выше,\n2. использования очень широких расстояний\n3. пропуска нот\n\n## Voice Leading\n\nКогда мы хотим осмысленно соединить аккорды в последовательности, выбранные voicings влияют на то, как каждый аккорд переходит к следующему.\nДавайте вернемся к \"The House of the Rising Sun\", на этот раз используя наши недавно приобретенные техники voicing:\n\nЭти voicings делают аккорды более связными и менее скачкообразными по сравнению с предыдущей версией, которая не фокусировалась на voicing.\nСпособ взаимодействия аккордов также называется `голосоведением`, напоминающим о том, как\nиндивидуальный хоровой голос двигался бы через последовательность аккордов.\n\nНапример, попробуйте спеть верхний голос в примере выше. Затем попробуйте то же самое\nв примере, не фокусирующемся на голосоведении. Какой легче?\n\nЕстественно, есть много способов, которыми прогрессия аккордов может быть озвучена, и нет определенного правильного или неправильного.\n\n## Символы аккордов\n\nМузыканты, играющие музыку на основе аккордов, часто используют `лид-шит`, который является упрощенной нотацией для музыкального произведения.\nЭти листы сжимают основные элементы, такие как аккорды, в символы, которые делают музыку легкой для чтения и следования.\nНапример, лид-шит для \"The House of the Rising Sun\" может включать аккорды, написанные так:\n\n```\nAm | C | D  | F\nAm | E | Am | E\n```\n\nЗдесь каждый символ состоит из `основного тона` аккорда и опционально `m` для обозначения минорного аккорда (только основной тон означает мажорный).\nМы могли бы зеркально отразить эту нотацию в strudel, используя функцию `pick`:\n\n## Функция voicing\n\nПридумывание хорошо звучащих voicings, которые хорошо соединяются, может быть трудным и трудоемким процессом.\nФункции `chord` и `voicing` могут использоваться для автоматизации этого:\n\nЗдесь мы также используем символы аккордов, но voicings будут автоматически сгенерированы с плавным `голосоведением`, минимизирующим скачки.\nЭто вдохновлено тем, как пианист или гитарист выбирал бы аккорды для аккомпанемента песни.\n\n## Словари Voicing\n\nФункция voicing внутренне использует так называемые `словари voicing`, которые также могут быть настроены:\n\nВ `словаре voicing` каждому символу аккорда назначается один или несколько voicings.\nФункция `voicing` затем выбирает voicing, который ближе всего к `anchor` (по умолчанию `c5`).\n\nУдобная вещь в этом подходе заключается в том, что `словарь voicing` может использоваться для воспроизведения любой прогрессии аккордов с автоматизированным голосоведением!\n\n## Словарь по умолчанию\n\nПри использовании словаря по умолчанию вы можете использовать эти символы аккордов:\n\n```\n2 5 6 7 9 11 13 69 add9\no h sus ^ - ^7 -7 7sus\nh7 o7 ^9 ^13 ^7#11 ^9#11\n^7#5 -6 -69 -^7 -^9 -9\n-add9 -11 -7b5 h9 -b6 -#5\n7b9 7#9 7#11 7b5 7#5 9#11\n9b5 9#5 7b13 7#9#5 7#9b5\n7#9#11 7b9#11 7b9b5 7b9#5\n7b9#9 7b9b13 7alt 13#11\n13b9 13#9 7b9sus 7susadd3\n9sus 13sus 7b13sus\naug M m M7 m7 M9 M13\nM7#11 M9#11 M7#5 m6 m69\nm^7 -M7 m^9 -M9 m9 madd9\nm11 m7b5 mb6 m#5 mM7 mM9\n```\n\nДоступные аккорды и формат очень вдохновлены [аккордами ireal pro](https://technimo.helpshift.com/hc/en/3-ireal-pro/faq/88-chord-symbols-used-in-ireal-pro/).\nНекоторые символы являются синонимами:\n\n- \"-\" то же самое, что \"m\", например C-7 = Cm7\n- \"^\" то же самое, что \"M\", например C^7 = CM7\n- \"+\" то же самое, что \"aug\"\n\nВы можете решить, какие вам больше нравятся. Не существует международного стандарта для этих символов.\nЧтобы получить полный аккорд, символы должны иметь префикс с основным питчем, например D7#11 - это аккорд 7#11 относительно питча D.\n\nВот все возможные аккорды с основным тоном C:\n\nОбратите внимание, что словарь по умолчанию содержит несколько способов (= `voicings`) для воспроизведения каждого символа аккорда.\nПо умолчанию функция `voicing` пытается минимизировать скачки.\nВы можете изменить выбранные voicings различными способами, которые теперь объясняются более подробно:\n\n## anchor\n\n`Anchor` - это нота, которая используется для выравнивания voicings:\n\nПо умолчанию anchor - это самая высокая возможная нота, которую может содержать voicing.\nПри принятии решения, какой voicing из словаря выбрать для определенного аккорда, побеждает voicing с верхней нотой, ближайшей к anchor.\n\nОбратите внимание, что anchors в примере выше совпадают с верхними нотами на пиано-ролле.\nКак и `note`, anchor принимает либо midi-номера, либо названия нот.\n\n## mode\n\nС помощью `mode` вы можете изменить способ, которым voicing относится к `anchor`:\n\nРежимы:\n\n- `below`: верхняя нота voicing ниже или равна anchor (по умолчанию)\n- `above`: нижняя нота voicing выше или равна anchor\n- `duck`: верхняя нота voicing ниже anchor\n- `root`: нижняя нота voicing всегда является основным тоном, ближайшим к anchor\n\n`Anchor` также может быть установлен изнутри функции `mode`:\n\n## n\n\nКонтрол `n` может использоваться с `voicing` для выбора отдельных нот:\n\n## Пример\n\nВот пример джазового блюза в F:\n\nАккорды повторно используются для мелодии, аккордов и басовой линии композиции.",
    "category": "understand",
    "keywords": [
      "понимание",
      "аккордовых",
      "voicings",
      "strudel",
      "midi",
      "house",
      "rising",
      "animals",
      "voicing",
      "voice",
      "leading",
      "pick",
      "chord",
      "anchor",
      "ireal",
      "https",
      "technimo",
      "helpshift",
      "symbols",
      "used"
    ],
    "path": "understand/voicings.mdx"
  },
  {
    "id": "workshop-first-effects",
    "title": "Первые эффекты",
    "content": "# Первые эффекты\n\nУ нас есть звуки, у нас есть ноты, теперь давайте посмотрим на эффекты!\n\n## Некоторые базовые эффекты\n\n**фильтр низких частот**\n\n**паттерн фильтра**\n\n**vowel**\n\n**gain**\n\nДавайте объединим всё вышеперечисленное в небольшую мелодию:\n\n**формирование звука с помощью adsr огибающей**\n\n**delay**\n\n**небольшая даб-мелодия**\n\nДавайте добавим бас, чтобы завершить это:\n\n**pan**\n\n**speed**\n\n**fast и slow**\n\nМы можем использовать `fast` и `slow` для изменения темпа pattern вне Mini-Notation:\n\nКстати, внутри Mini-Notation `fast` — это `*`, а `slow` — это `/`.\n\n## модуляция с помощью сигналов\n\nВместо пошагового изменения значений мы также можем управлять ими с помощью сигналов:\n\n**установка диапазона**\n\nПо умолчанию волны колеблются от 0 до 1. Мы можем изменить это с помощью `range`:\n\nМы можем изменить скорость модуляции с помощью slow / fast:\n\n## Итоги\n\n| название | пример                                                                                                           |\n| -------- | ---------------------------------------------------------------------------------------------------------------- |\n| lpf      |                         |\n| vowel    |                          |\n| gain     |                                                |\n| delay    |                                                 |\n| room     |                                                  |\n| pan      |                                                |\n| speed    |                                      |\n| сигналы  | `sine`, `saw`, `square`, `tri`, `rand`, `perlin`<br/> |\n| range    |                                         |\n\nТеперь давайте взглянем на некоторые типичные для Tidal [эффекты pattern](/workshop/pattern-effects).",
    "category": "workshop",
    "keywords": [
      "первые",
      "эффекты",
      "vowel",
      "gain",
      "adsr",
      "delay",
      "speed",
      "fast",
      "slow",
      "pattern",
      "mini",
      "notation",
      "range",
      "room",
      "sine",
      "square",
      "rand",
      "perlin",
      "tidal",
      "workshop"
    ],
    "path": "workshop/first-effects.mdx"
  },
  {
    "id": "workshop-first-notes",
    "title": "Первые ноты",
    "content": "# Первые ноты\n\nДавайте посмотрим, как мы можем воспроизводить ноты\n\n## числа и ноты\n\n**воспроизведение нот с помощью чисел**\n\n**воспроизведение нот с помощью букв**\n\n**добавьте бемоль или диез, чтобы сыграть черные клавиши**\n\n**воспроизведение нот с буквами в разных октавах**\n\nЕсли вы не знакомы с буквенной системой обозначения нот, вам будет проще использовать числа.\nБольшинство примеров ниже будет использовать числа по этой причине.\nМы также позже рассмотрим способы упростить игру правильных нот.\n\n## изменение звука\n\nТак же, как и с неритмичными звуками, мы можем изменить звук наших нот с помощью `sound`:\n\n{/* c2 g2, e3 b3 d4 e4 */}\n\n**переключение между звуками**\n\n**наложение нескольких звуков**\n\n## Более длинные последовательности\n\n**Разделение последовательностей с помощью `/` для замедления**\n\n**Воспроизведение одной на cycle с помощью `< ... >`**\n\nВ предыдущей главе мы узнали, что `< ... >` (угловые скобки) можно использовать для воспроизведения только одной вещи за cycle,\nчто полезно и для более длинных мелодий:\n\n**Воспроизведение одной последовательности на cycle**\n\nМы можем комбинировать 2 типа скобок различными способами.\nВот пример повторяющейся басовой линии:\n\n**Чередование между несколькими вещами**\n\nЭто также полезно для неритмичных звуков:\n\n## Гаммы\n\nНайти правильные ноты может быть сложно.. Гаммы (scales) здесь, чтобы помочь:\n\n**автоматизация гамм**\n\nКак и всё остальное, мы можем автоматизировать гамму с помощью pattern:\n\n## Повторение и удлинение\n\n**Удлинение с помощью @**\n\n**Удлинение внутри подпоследовательностей**\n\n**Репликация**\n\n## Итоги\n\nДавайте подведем итоги того, что мы узнали в этой главе:\n\n| Концепция   | Синтаксис | Пример                                                   |\n| ----------- | --------- | -------------------------------------------------------- |\n| Замедление  | \\/        |  |\n| Чередование | \\<\\>      |  |\n| Удлинение   | @         |        |\n| Репликация  | !         |        |\n\nНовые функции:\n\n| Название | Описание                                 | Пример                                                                            |\n| -------- | ---------------------------------------- | --------------------------------------------------------------------------------- |\n| note     | установить высоту как число или букву    |                |\n| scale    | интерпретировать `n` как ступень гаммы   |  |\n| $:       | воспроизводить паттерны параллельно      |              |\n\n## Примеры\n\n**Классная басовая линия**\n\n**Классная мелодия**\n\n**Классные ударные**\n\n**Если бы только был способ воспроизводить всё вышеперечисленное одновременно.......**\n\n## Воспроизведение нескольких паттернов\n\nЕсли вы хотите воспроизводить несколько паттернов одновременно, убедитесь, что написали `$:` перед каждым:\n\nЭто начинает звучать как настоящая музыка! У нас есть звуки, у нас есть ноты, теперь не хватает последнего кусочка головоломки: [эффектов](/workshop/first-effects)",
    "category": "workshop",
    "keywords": [
      "первые",
      "ноты",
      "sound",
      "cycle",
      "scales",
      "pattern",
      "note",
      "scale",
      "workshop",
      "first",
      "effects"
    ],
    "path": "workshop/first-notes.mdx"
  },
  {
    "id": "workshop-first-sounds",
    "title": "Первые звуки",
    "content": "# Первые звуки\n\nЭто первая глава воркшопа Strudel, рады видеть вас на борту!\n\n## Поля с кодом\n\nВоркшоп полон интерактивных полей с кодом. Давайте научимся ими пользоваться. Вот одно из них:\n\nПоздравляем, теперь вы занимаетесь live coding!\n\n## Звуки\n\nМы только что воспроизвели звук с помощью `sound` вот так:\n\n**Изменение номера sample с помощью :**\n\nОдин звук может содержать несколько samples (аудиофайлов).\n\nВы можете выбрать sample, добавив `:` и число к имени:\n\nТеперь вы знаете, как использовать разные звуки.\nПока мы остановимся на этой небольшой подборке звуков, но позже узнаем, как загружать собственные звуки.\n\n## Звуки ударных\n\nПо умолчанию Strudel поставляется с широким выбором звуков ударных:\n\nЧтобы изменить звучание ударных, мы можем использовать `bank` для смены драм-машины:\n\nВ этом примере `RolandTR909` — это название драм-машины, которую мы используем.\nЭто знаменитая драм-машина для house и techno битов.\n\n## Последовательности\n\nВ последнем примере мы уже видели, что можно воспроизводить несколько звуков в последовательности, разделяя их пробелом:\n\nОбратите внимание, как текущий воспроизводимый звук подсвечивается в коде и визуализируется ниже.\n\n**Чем длиннее последовательность, тем быстрее она выполняется**\n\nСодержимое последовательности будет сжато в то, что называется cycle. По умолчанию cycle длится 2 секунды.\n\n**Один на cycle с помощью `< .. >`**\n\nВот та же последовательность, но на этот раз окруженная `< .. >` (угловыми скобками):\n\nЭто будет воспроизводить только один звук за cycle. С этими скобками темп не меняется, когда мы добавляем или удаляем элементы!\n\nТак как сейчас это очень медленно, мы можем снова ускорить это так:\n\nЗдесь `*8` означает, что мы делаем всё это в 8 раз быстрее.\n\n**изменение темпа с помощью setcpm**\n\n**Добавление пауз в последовательность с помощью '-' или '~'**\n\n**Подпоследовательности с [квадратными скобками]**\n\nПодобно всей последовательности, содержимое подпоследовательности будет сжато до собственной длины.\n\n**Умножение: Ускорение**\n\n**Умножение: Ускорение подпоследовательностей**\n\n**Умножение: Оооочень сильное ускорение**\n\n**Подподпоследовательности с [[двойными скобками]]**\n\n**Воспроизведение последовательностей параллельно с помощью запятой**\n\nВы можете использовать столько запятых, сколько хотите:\n\nЗапятые также могут использоваться внутри подпоследовательностей:\n\n**Несколько строк с обратными кавычками**\n\n**выбор номеров samples отдельно**\n\nВместо того чтобы выбирать номера samples по одному:\n\nМы также можем использовать функцию `n`, чтобы сделать это короче и читабельнее:\n\n## Итоги\n\nТеперь мы изучили основы так называемой Mini-Notation, ритмического языка Tidal.\nВот что мы изучили к настоящему моменту:\n\n| Концепция         | Синтаксис | Пример                                                                  |\n| ----------------- | --------- | ----------------------------------------------------------------------- |\n| Последовательность| пробел    |                |\n| Номер sample      | :x        |        |\n| Паузы             | - или ~   |        |\n| Чередование       | \\<\\>      |      |\n| Подпоследовательности | \\[\\]  |    |\n| Подподпоследовательности | \\[\\[\\]\\] |  |\n| Ускорение         | \\*        |               |\n| Параллельно       | ,         |         |\n\nMini-Notation обычно используется внутри какой-либо функции. Вот функции, которые мы видели к настоящему моменту:\n\n| Название | Описание                             | Пример                                                                            |\n| -------- | ------------------------------------ | --------------------------------------------------------------------------------- |\n| sound    | воспроизводит звук с указанным именем|                      |\n| bank     | выбирает sound bank                  |  |\n| setcpm   | устанавливает темп в циклах в минуту |          |\n| n        | выбрать номер sample                 |            |\n\n## Примеры\n\n**Базовый рок-бит**\n\n**Классический house**\n\nWe Will Rock you\n\n**Yellow Magic Orchestra - Firecracker**\n\n**Имитация 16-шагового секвенсора**\n\n**Еще один**\n\n**Необычные ударные**\n\nТеперь, когда мы знаем основы создания битов, давайте посмотрим, как можно воспроизводить [ноты](/workshop/first-notes)",
    "category": "workshop",
    "keywords": [
      "первые",
      "звуки",
      "strudel",
      "live",
      "coding",
      "sound",
      "sample",
      "samples",
      "bank",
      "house",
      "techno",
      "cycle",
      "setcpm",
      "mini",
      "notation",
      "tidal",
      "will",
      "rock",
      "yellow",
      "magic"
    ],
    "path": "workshop/first-sounds.mdx"
  },
  {
    "id": "workshop-getting-started",
    "title": "Начало работы",
    "content": "# Добро пожаловать\n\n<div className=\"w-32 animate-pulse md:float-right ml-8 text-6xl\">🍞</div>\n\nДобро пожаловать в документацию Bulka!\nВы попали в нужное место, если хотите научиться создавать музыку с помощью кода.\n\n## Что такое Bulka?\n\nС Bulka вы можете выразительно писать динамические музыкальные произведения.<br/>\nЭто порт языка паттернов [Tidal Cycles](https://tidalcycles.org/) на JavaScript.<br/>\nВам не нужно знать JavaScript или Tidal Cycles, чтобы создавать музыку с Bulka.\nЭтот интерактивный туториал проведёт вас через основы.<br/>\nЛучшее место для создания музыки — [Bulka REPL](/)\n\n<div className=\"clear-both\" />\n\n## Что можно делать с Bulka?\n\n- **лайв-кодинг музыки**: создавайте музыку кодом в реальном времени — никаких установок, работает прямо в браузере\n- **алгоритмическая композиция**: бесконечные вариации из нескольких строк кода благодаря уникальному подходу Tidal к паттернам\n- **тысячи звуков из коробки**: драм-машины 808/909, синтезаторы, оркестровые инструменты, фолк со всего мира — всё уже готово к использованию\n- **AI-ассистент**: не знаешь с чего начать? Встроенный агент напишет трек по твоему описанию (OpenAI, Anthropic, Google — на выбор)\n- **визуализация Hydra**: аудио-реактивные визуалы прямо в редакторе — твоя музыка оживает на экране\n- **шеринг одной ссылкой**: скинул ссылку — друг слышит твой трек, без регистрации и скачивания\n- **обучение**: низкий порог входа делает Bulka идеальным для обучения музыке и программированию одновременно\n- **интеграция**: MIDI, OSC — используй Bulka как секвенсор в своём сетапе с железом и DAW\n\n## Примеры\n\nВот несколько примеров того, как может звучать Bulka:\n\nЭти примеры не могут полностью охватить всё разнообразие возможностей. Посмотрите [showcase](/intro/showcase/) с видео от пользователей Strudel.\n\n## Начинаем\n\nЛучший способ начать изучение — пройти воркшоп.\nЕсли вы готовы погрузиться, начните с ваших [первых звуков](/workshop/first-sounds)",
    "category": "workshop",
    "keywords": [
      "начало",
      "работы",
      "classname",
      "animate",
      "pulse",
      "float",
      "right",
      "text",
      "bulka",
      "tidal",
      "cycles",
      "https",
      "tidalcycles",
      "javascript",
      "repl",
      "clear",
      "both",
      "openai",
      "anthropic",
      "google"
    ],
    "path": "workshop/getting-started.mdx"
  },
  {
    "id": "workshop-pattern-effects",
    "title": "Эффекты паттернов",
    "content": "# Эффекты паттернов\n\nДо сих пор большинство функций, которые мы видели, — это то, на что обычно способны другие музыкальные программы: секвенсирование звуков, воспроизведение нот, управление эффектами.\n\nВ этой главе мы рассмотрим функции, которые более уникальны для tidal.\n\n**обратные паттерны с помощью rev**\n\n**воспроизведение pattern слева и его модификация справа с помощью jux**\n\nЭто то же самое, что:\n\nДавайте визуализируем, что здесь происходит:\n\n**несколько темпов**\n\nЭто как если бы мы делали\n\n**add**\n\nМы можем добавлять столько раз, сколько захотим:\n\n**add с scale**\n\n**время складывать**\n\n**ply**\n\nэто как написать:\n\n**off**\n\noff также полезен для модификации других звуков и может быть даже вложенным:\n\n| название | описание                              | пример                                                                              |\n| -------- | ------------------------------------- | ----------------------------------------------------------------------------------- |\n| rev      | обратить порядок                      |    |\n| jux      | разделить лево/право, модифицировать право |  |\n| add      | добавить числа / ноты                 |  |\n| ply      | ускорить каждое событие n раз         |            |\n| off      | копировать, сдвигать время и модифицировать |  |",
    "category": "workshop",
    "keywords": [
      "эффекты",
      "паттернов",
      "tidal",
      "pattern",
      "scale"
    ],
    "path": "workshop/pattern-effects.mdx"
  },
  {
    "id": "workshop-recap",
    "title": "Итоги",
    "content": "# Итоги воркшопа\n\nЭта страница — просто список всех функций, охваченных в воркшопе!\n\n## Mini Notation\n\n| Концепция                | Синтаксис | Пример                                                                |\n| ------------------------ | --------- | --------------------------------------------------------------------- |\n| Последовательность       | пробел    |  |\n| Номер sample             | :x        |      |\n| Паузы                    | ~         |      |\n| Подпоследовательности    | \\[\\]      |  |\n| Подподпоследовательности | \\[\\[\\]\\]  |     |\n| Ускорение                | \\*        |             |\n| Параллельно              | ,         |       |\n| Замедление               | \\/        |               |\n| Чередование              | \\<\\>      |                   |\n| Удлинение                | @         |                     |\n| Репликация               | !         |                     |\n\n## Звуки\n\n| Название | Описание                              | Пример                                                                  |\n| -------- | ------------------------------------- | ----------------------------------------------------------------------- |\n| sound    | воспроизводит звук с указанным именем |                      |\n| bank     | выбирает sound bank                   |  |\n| n        | выбрать номер sample                  |          |\n\n## Ноты\n\n| Название  | Описание                            | Пример                                                                            |\n| --------- | ----------------------------------- | --------------------------------------------------------------------------------- |\n| note      | установить высоту как число или букву |                |\n| n + scale | установить ноту в гамме             |  |\n| $:        | воспроизводить паттерны параллельно |              |\n\n## Аудиоэффекты\n\n| название | пример                                                                                  |\n| -------- | --------------------------------------------------------------------------------------- |\n| lpf      |  |\n| vowel    |  |\n| gain     |                       |\n| delay    |                        |\n| room     |                         |\n| pan      |                       |\n| speed    |             |\n| range    |                |\n\n## Эффекты паттернов\n\n| название | описание                                    | пример                                                                              |\n| -------- | ------------------------------------------- | ----------------------------------------------------------------------------------- |\n| setcpm   | устанавливает темп в циклах в минуту        |           |\n| fast     | ускорить                                    |               |\n| slow     | замедлить                                   |               |\n| rev      | обратить порядок                            |            |\n| jux      | разделить лево/право, модифицировать право  |         |\n| add      | добавить числа / ноты                       |  |\n| ply      | ускорить каждое событие n раз               |                      |\n| off      | копировать, сдвигать время и модифицировать |       |",
    "category": "workshop",
    "keywords": [
      "итоги",
      "mini",
      "notation",
      "sample",
      "sound",
      "bank",
      "note",
      "scale",
      "vowel",
      "gain",
      "delay",
      "room",
      "speed",
      "range",
      "setcpm",
      "fast",
      "slow"
    ],
    "path": "workshop/recap.mdx"
  }
]